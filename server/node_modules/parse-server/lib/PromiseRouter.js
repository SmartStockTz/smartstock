"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _node = _interopRequireDefault(require("parse/node"));

var _express = _interopRequireDefault(require("express"));

var _logger = _interopRequireDefault(require("./logger"));

var _util = require("util");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// A router that is based on promises rather than req/res/next.
// This is intended to replace the use of express.Router to handle
// subsections of the API surface.
// This will make it easier to have methods like 'batch' that
// themselves use our routing information, without disturbing express
// components that external developers may be modifying.
const Layer = require('express/lib/router/layer');

function validateParameter(key, value) {
  if (key == 'className') {
    if (value.match(/_?[A-Za-z][A-Za-z_0-9]*/)) {
      return value;
    }
  } else if (key == 'objectId') {
    if (value.match(/[A-Za-z0-9]+/)) {
      return value;
    }
  } else {
    return value;
  }
}

class PromiseRouter {
  // Each entry should be an object with:
  // path: the path to route, in express format
  // method: the HTTP method that this route handles.
  //   Must be one of: POST, GET, PUT, DELETE
  // handler: a function that takes request, and returns a promise.
  //   Successful handlers should resolve to an object with fields:
  //     status: optional. the http status code. defaults to 200
  //     response: a json object with the content of the response
  //     location: optional. a location header
  constructor(routes = [], appId) {
    this.routes = routes;
    this.appId = appId;
    this.mountRoutes();
  } // Leave the opportunity to
  // subclasses to mount their routes by overriding


  mountRoutes() {} // Merge the routes into this one


  merge(router) {
    for (var route of router.routes) {
      this.routes.push(route);
    }
  }

  route(method, path, ...handlers) {
    switch (method) {
      case 'POST':
      case 'GET':
      case 'PUT':
      case 'DELETE':
        break;

      default:
        throw 'cannot route method: ' + method;
    }

    let handler = handlers[0];

    if (handlers.length > 1) {
      handler = function (req) {
        return handlers.reduce((promise, handler) => {
          return promise.then(() => {
            return handler(req);
          });
        }, Promise.resolve());
      };
    }

    this.routes.push({
      path: path,
      method: method,
      handler: handler,
      layer: new Layer(path, null, handler)
    });
  } // Returns an object with:
  //   handler: the handler that should deal with this request
  //   params: any :-params that got parsed from the path
  // Returns undefined if there is no match.


  match(method, path) {
    for (var route of this.routes) {
      if (route.method != method) {
        continue;
      }

      const layer = route.layer || new Layer(route.path, null, route.handler);
      const match = layer.match(path);

      if (match) {
        const params = layer.params;
        Object.keys(params).forEach(key => {
          params[key] = validateParameter(key, params[key]);
        });
        return {
          params: params,
          handler: route.handler
        };
      }
    }
  } // Mount the routes on this router onto an express app (or express router)


  mountOnto(expressApp) {
    this.routes.forEach(route => {
      const method = route.method.toLowerCase();
      const handler = makeExpressHandler(this.appId, route.handler);
      expressApp[method].call(expressApp, route.path, handler);
    });
    return expressApp;
  }

  expressRouter() {
    return this.mountOnto(_express.default.Router());
  }

  tryRouteRequest(method, path, request) {
    var match = this.match(method, path);

    if (!match) {
      throw new _node.default.Error(_node.default.Error.INVALID_JSON, 'cannot route ' + method + ' ' + path);
    }

    request.params = match.params;
    return new Promise((resolve, reject) => {
      match.handler(request).then(resolve, reject);
    });
  }

} // A helper function to make an express handler out of a a promise
// handler.
// Express handlers should never throw; if a promise handler throws we
// just treat it like it resolved to an error.


exports.default = PromiseRouter;

function makeExpressHandler(appId, promiseHandler) {
  return function (req, res, next) {
    try {
      const url = maskSensitiveUrl(req);
      const body = Object.assign({}, req.body);
      const method = req.method;
      const headers = req.headers;

      _logger.default.logRequest({
        method,
        url,
        headers,
        body
      });

      promiseHandler(req).then(result => {
        if (!result.response && !result.location && !result.text) {
          _logger.default.error('the handler did not include a "response" or a "location" field');

          throw 'control should not get here';
        }

        _logger.default.logResponse({
          method,
          url,
          result
        });

        var status = result.status || 200;
        res.status(status);

        if (result.text) {
          res.send(result.text);
          return;
        }

        if (result.location) {
          res.set('Location', result.location); // Override the default expressjs response
          // as it double encodes %encoded chars in URL

          if (!result.response) {
            res.send('Found. Redirecting to ' + result.location);
            return;
          }
        }

        if (result.headers) {
          Object.keys(result.headers).forEach(header => {
            res.set(header, result.headers[header]);
          });
        }

        res.json(result.response);
      }, error => next(error)).catch(e => {
        _logger.default.error(`Error generating response. ${(0, _util.inspect)(e)}`, {
          error: e
        });

        next(e);
      });
    } catch (e) {
      _logger.default.error(`Error handling request: ${(0, _util.inspect)(e)}`, {
        error: e
      });

      next(e);
    }
  };
}

function maskSensitiveUrl(req) {
  let maskUrl = req.originalUrl.toString();
  const shouldMaskUrl = req.method === 'GET' && req.originalUrl.includes('/login') && !req.originalUrl.includes('classes');

  if (shouldMaskUrl) {
    maskUrl = _logger.default.maskSensitiveUrl(maskUrl);
  }

  return maskUrl;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9Qcm9taXNlUm91dGVyLmpzIl0sIm5hbWVzIjpbIkxheWVyIiwicmVxdWlyZSIsInZhbGlkYXRlUGFyYW1ldGVyIiwia2V5IiwidmFsdWUiLCJtYXRjaCIsIlByb21pc2VSb3V0ZXIiLCJjb25zdHJ1Y3RvciIsInJvdXRlcyIsImFwcElkIiwibW91bnRSb3V0ZXMiLCJtZXJnZSIsInJvdXRlciIsInJvdXRlIiwicHVzaCIsIm1ldGhvZCIsInBhdGgiLCJoYW5kbGVycyIsImhhbmRsZXIiLCJsZW5ndGgiLCJyZXEiLCJyZWR1Y2UiLCJwcm9taXNlIiwidGhlbiIsIlByb21pc2UiLCJyZXNvbHZlIiwibGF5ZXIiLCJwYXJhbXMiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsIm1vdW50T250byIsImV4cHJlc3NBcHAiLCJ0b0xvd2VyQ2FzZSIsIm1ha2VFeHByZXNzSGFuZGxlciIsImNhbGwiLCJleHByZXNzUm91dGVyIiwiZXhwcmVzcyIsIlJvdXRlciIsInRyeVJvdXRlUmVxdWVzdCIsInJlcXVlc3QiLCJQYXJzZSIsIkVycm9yIiwiSU5WQUxJRF9KU09OIiwicmVqZWN0IiwicHJvbWlzZUhhbmRsZXIiLCJyZXMiLCJuZXh0IiwidXJsIiwibWFza1NlbnNpdGl2ZVVybCIsImJvZHkiLCJhc3NpZ24iLCJoZWFkZXJzIiwibG9nIiwibG9nUmVxdWVzdCIsInJlc3VsdCIsInJlc3BvbnNlIiwibG9jYXRpb24iLCJ0ZXh0IiwiZXJyb3IiLCJsb2dSZXNwb25zZSIsInN0YXR1cyIsInNlbmQiLCJzZXQiLCJoZWFkZXIiLCJqc29uIiwiY2F0Y2giLCJlIiwibWFza1VybCIsIm9yaWdpbmFsVXJsIiwidG9TdHJpbmciLCJzaG91bGRNYXNrVXJsIiwiaW5jbHVkZXMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFPQTs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQVZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BLE1BQU1BLEtBQUssR0FBR0MsT0FBTyxD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Q0wsRUFvQ0lHLEtBQUssSUFBSVosSUFBSSxDQUFDWSxLQUFELENBcENqQixFQXNDR08sS0F0Q0gsQ0FzQ1NDLENBQUMsSUFBSTtBQUNWZCx3QkFBSU0sS0FBSixDQUFXLDhCQUE2QixtQkFBUVEsQ0FBUixDQUFXLEVBQW5ELEVBQXNEO0FBQUVSLFVBQUFBLEtBQUssRUFBRVE7QUFBVCxTQUF0RDs7QUFDQXBCLFFBQUFBLElBQUksQ0FBQ29CLENBQUQsQ0FBSjtBQUNELE9BekNIO0FBMENELEtBckRELENBcURFLE9BQU9BLENBQVAsRUFBVTtBQUNWZCxzQkFBSU0sS0FBSixDQUFXLDJCQUEwQixtQkFBUVEsQ0FBUixDQUFXLEVBQWhELEVBQW1EO0FBQUVSLFFBQUFBLEtBQUssRUFBRVE7QUFBVCxPQUFuRDs7QUFDQXBCLE1BQUFBLElBQUksQ0FBQ29CLENBQUQsQ0FBSjtBQUNEO0FBQ0YsR0ExREQ7QUEyREQ7O0FBRUQsU0FBU2xCLGdCQUFULENBQTBCN0IsR0FBMUIsRUFBK0I7QUFDN0IsTUFBSWdELE9BQU8sR0FBR2hELEdBQUcsQ0FBQ2lELFdBQUosQ0FBZ0JDLFFBQWhCLEVBQWQ7QUFDQSxRQUFNQyxhQUFhLEdBQ2pCbkQsR0FBRyxDQUFDTCxNQUFKLEtBQWUsS0FBZixJQUNBSyxHQUFHLENBQUNpRCxXQUFKLENBQWdCRyxRQUFoQixDQUF5QixRQUF6QixDQURBLElBRUEsQ0FBQ3BELEdBQUcsQ0FBQ2lELFdBQUosQ0FBZ0JHLFFBQWhCLENBQXlCLFNBQXpCLENBSEg7O0FBSUEsTUFBSUQsYUFBSixFQUFtQjtBQUNqQkgsSUFBQUEsT0FBTyxHQUFHZixnQkFBSUosZ0JBQUosQ0FBcUJtQixPQUFyQixDQUFWO0FBQ0Q7O0FBQ0QsU0FBT0EsT0FBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQSByb3V0ZXIgdGhhdCBpcyBiYXNlZCBvbiBwcm9taXNlcyByYXRoZXIgdGhhbiByZXEvcmVzL25leHQuXG4vLyBUaGlzIGlzIGludGVuZGVkIHRvIHJlcGxhY2UgdGhlIHVzZSBvZiBleHByZXNzLlJvdXRlciB0byBoYW5kbGVcbi8vIHN1YnNlY3Rpb25zIG9mIHRoZSBBUEkgc3VyZmFjZS5cbi8vIFRoaXMgd2lsbCBtYWtlIGl0IGVhc2llciB0byBoYXZlIG1ldGhvZHMgbGlrZSAnYmF0Y2gnIHRoYXRcbi8vIHRoZW1zZWx2ZXMgdXNlIG91ciByb3V0aW5nIGluZm9ybWF0aW9uLCB3aXRob3V0IGRpc3R1cmJpbmcgZXhwcmVzc1xuLy8gY29tcG9uZW50cyB0aGF0IGV4dGVybmFsIGRldmVsb3BlcnMgbWF5IGJlIG1vZGlmeWluZy5cblxuaW1wb3J0IFBhcnNlIGZyb20gJ3BhcnNlL25vZGUnO1xuaW1wb3J0IGV4cHJlc3MgZnJvbSAnZXhwcmVzcyc7XG5pbXBvcnQgbG9nIGZyb20gJy4vbG9nZ2VyJztcbmltcG9ydCB7IGluc3BlY3QgfSBmcm9tICd1dGlsJztcbmNvbnN0IExheWVyID0gcmVxdWlyZSgnZXhwcmVzcy9saWIvcm91dGVyL2xheWVyJyk7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUGFyYW1ldGVyKGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSA9PSAnY2xhc3NOYW1lJykge1xuICAgIGlmICh2YWx1ZS5tYXRjaCgvXz9bQS1aYS16XVtBLVphLXpfMC05XSovKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChrZXkgPT0gJ29iamVjdElkJykge1xuICAgIGlmICh2YWx1ZS5tYXRjaCgvW0EtWmEtejAtOV0rLykpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByb21pc2VSb3V0ZXIge1xuICAvLyBFYWNoIGVudHJ5IHNob3VsZCBiZSBhbiBvYmplY3Qgd2l0aDpcbiAgLy8gcGF0aDogdGhlIHBhdGggdG8gcm91dGUsIGluIGV4cHJlc3MgZm9ybWF0XG4gIC8vIG1ldGhvZDogdGhlIEhUVFAgbWV0aG9kIHRoYXQgdGhpcyByb3V0ZSBoYW5kbGVzLlxuICAvLyAgIE11c3QgYmUgb25lIG9mOiBQT1NULCBHRVQsIFBVVCwgREVMRVRFXG4gIC8vIGhhbmRsZXI6IGEgZnVuY3Rpb24gdGhhdCB0YWtlcyByZXF1ZXN0LCBhbmQgcmV0dXJucyBhIHByb21pc2UuXG4gIC8vICAgU3VjY2Vzc2Z1bCBoYW5kbGVycyBzaG91bGQgcmVzb2x2ZSB0byBhbiBvYmplY3Qgd2l0aCBmaWVsZHM6XG4gIC8vICAgICBzdGF0dXM6IG9wdGlvbmFsLiB0aGUgaHR0cCBzdGF0dXMgY29kZS4gZGVmYXVsdHMgdG8gMjAwXG4gIC8vICAgICByZXNwb25zZTogYSBqc29uIG9iamVjdCB3aXRoIHRoZSBjb250ZW50IG9mIHRoZSByZXNwb25zZVxuICAvLyAgICAgbG9jYXRpb246IG9wdGlvbmFsLiBhIGxvY2F0aW9uIGhlYWRlclxuICBjb25zdHJ1Y3Rvcihyb3V0ZXMgPSBbXSwgYXBwSWQpIHtcbiAgICB0aGlzLnJvdXRlcyA9IHJvdXRlcztcbiAgICB0aGlzLmFwcElkID0gYXBwSWQ7XG4gICAgdGhpcy5tb3VudFJvdXRlcygpO1xuICB9XG5cbiAgLy8gTGVhdmUgdGhlIG9wcG9ydHVuaXR5IHRvXG4gIC8vIHN1YmNsYXNzZXMgdG8gbW91bnQgdGhlaXIgcm91dGVzIGJ5IG92ZXJyaWRpbmdcbiAgbW91bnRSb3V0ZXMoKSB7fVxuXG4gIC8vIE1lcmdlIHRoZSByb3V0ZXMgaW50byB0aGlzIG9uZVxuICBtZXJnZShyb3V0ZXIpIHtcbiAgICBmb3IgKHZhciByb3V0ZSBvZiByb3V0ZXIucm91dGVzKSB7XG4gICAgICB0aGlzLnJvdXRlcy5wdXNoKHJvdXRlKTtcbiAgICB9XG4gIH1cblxuICByb3V0ZShtZXRob2QsIHBhdGgsIC4uLmhhbmRsZXJzKSB7XG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgIGNhc2UgJ1BPU1QnOlxuICAgICAgY2FzZSAnR0VUJzpcbiAgICAgIGNhc2UgJ1BVVCc6XG4gICAgICBjYXNlICdERUxFVEUnOlxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93ICdjYW5ub3Qgcm91dGUgbWV0aG9kOiAnICsgbWV0aG9kO1xuICAgIH1cblxuICAgIGxldCBoYW5kbGVyID0gaGFuZGxlcnNbMF07XG5cbiAgICBpZiAoaGFuZGxlcnMubGVuZ3RoID4gMSkge1xuICAgICAgaGFuZGxlciA9IGZ1bmN0aW9uKHJlcSkge1xuICAgICAgICByZXR1cm4gaGFuZGxlcnMucmVkdWNlKChwcm9taXNlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlcihyZXEpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBQcm9taXNlLnJlc29sdmUoKSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMucm91dGVzLnB1c2goe1xuICAgICAgcGF0aDogcGF0aCxcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgaGFuZGxlcjogaGFuZGxlcixcbiAgICAgIGxheWVyOiBuZXcgTGF5ZXIocGF0aCwgbnVsbCwgaGFuZGxlciksXG4gICAgfSk7XG4gIH1cblxuICAvLyBSZXR1cm5zIGFuIG9iamVjdCB3aXRoOlxuICAvLyAgIGhhbmRsZXI6IHRoZSBoYW5kbGVyIHRoYXQgc2hvdWxkIGRlYWwgd2l0aCB0aGlzIHJlcXVlc3RcbiAgLy8gICBwYXJhbXM6IGFueSA6LXBhcmFtcyB0aGF0IGdvdCBwYXJzZWQgZnJvbSB0aGUgcGF0aFxuICAvLyBSZXR1cm5zIHVuZGVmaW5lZCBpZiB0aGVyZSBpcyBubyBtYXRjaC5cbiAgbWF0Y2gobWV0aG9kLCBwYXRoKSB7XG4gICAgZm9yICh2YXIgcm91dGUgb2YgdGhpcy5yb3V0ZXMpIHtcbiAgICAgIGlmIChyb3V0ZS5tZXRob2QgIT0gbWV0aG9kKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgbGF5ZXIgPSByb3V0ZS5sYXllciB8fCBuZXcgTGF5ZXIocm91dGUucGF0aCwgbnVsbCwgcm91dGUuaGFuZGxlcik7XG4gICAgICBjb25zdCBtYXRjaCA9IGxheWVyLm1hdGNoKHBhdGgpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IGxheWVyLnBhcmFtcztcbiAgICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgcGFyYW1zW2tleV0gPSB2YWxpZGF0ZVBhcmFtZXRlcihrZXksIHBhcmFtc1trZXldKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IHBhcmFtczogcGFyYW1zLCBoYW5kbGVyOiByb3V0ZS5oYW5kbGVyIH07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gTW91bnQgdGhlIHJvdXRlcyBvbiB0aGlzIHJvdXRlciBvbnRvIGFuIGV4cHJlc3MgYXBwIChvciBleHByZXNzIHJvdXRlcilcbiAgbW91bnRPbnRvKGV4cHJlc3NBcHApIHtcbiAgICB0aGlzLnJvdXRlcy5mb3JFYWNoKHJvdXRlID0+IHtcbiAgICAgIGNvbnN0IG1ldGhvZCA9IHJvdXRlLm1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgY29uc3QgaGFuZGxlciA9IG1ha2VFeHByZXNzSGFuZGxlcih0aGlzLmFwcElkLCByb3V0ZS5oYW5kbGVyKTtcbiAgICAgIGV4cHJlc3NBcHBbbWV0aG9kXS5jYWxsKGV4cHJlc3NBcHAsIHJvdXRlLnBhdGgsIGhhbmRsZXIpO1xuICAgIH0pO1xuICAgIHJldHVybiBleHByZXNzQXBwO1xuICB9XG5cbiAgZXhwcmVzc1JvdXRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5tb3VudE9udG8oZXhwcmVzcy5Sb3V0ZXIoKSk7XG4gIH1cblxuICB0cnlSb3V0ZVJlcXVlc3QobWV0aG9kLCBwYXRoLCByZXF1ZXN0KSB7XG4gICAgdmFyIG1hdGNoID0gdGhpcy5tYXRjaChtZXRob2QsIHBhdGgpO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZS5FcnJvcihcbiAgICAgICAgUGFyc2UuRXJyb3IuSU5WQUxJRF9KU09OLFxuICAgICAgICAnY2Fubm90IHJvdXRlICcgKyBtZXRob2QgKyAnICcgKyBwYXRoXG4gICAgICApO1xuICAgIH1cbiAgICByZXF1ZXN0LnBhcmFtcyA9IG1hdGNoLnBhcmFtcztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbWF0Y2guaGFuZGxlcihyZXF1ZXN0KS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgfSk7XG4gIH1cbn1cblxuLy8gQSBoZWxwZXIgZnVuY3Rpb24gdG8gbWFrZSBhbiBleHByZXNzIGhhbmRsZXIgb3V0IG9mIGEgYSBwcm9taXNlXG4vLyBoYW5kbGVyLlxuLy8gRXhwcmVzcyBoYW5kbGVycyBzaG91bGQgbmV2ZXIgdGhyb3c7IGlmIGEgcHJvbWlzZSBoYW5kbGVyIHRocm93cyB3ZVxuLy8ganVzdCB0cmVhdCBpdCBsaWtlIGl0IHJlc29sdmVkIHRvIGFuIGVycm9yLlxuZnVuY3Rpb24gbWFrZUV4cHJlc3NIYW5kbGVyKGFwcElkLCBwcm9taXNlSGFuZGxlcikge1xuICByZXR1cm4gZnVuY3Rpb24ocmVxLCByZXMsIG5leHQpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdXJsID0gbWFza1NlbnNpdGl2ZVVybChyZXEpO1xuICAgICAgY29uc3QgYm9keSA9IE9iamVjdC5hc3NpZ24oe30sIHJlcS5ib2R5KTtcbiAgICAgIGNvbnN0IG1ldGhvZCA9IHJlcS5tZXRob2Q7XG4gICAgICBjb25zdCBoZWFkZXJzID0gcmVxLmhlYWRlcnM7XG4gICAgICBsb2cubG9nUmVxdWVzdCh7XG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgdXJsLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBib2R5LFxuICAgICAgfSk7XG4gICAgICBwcm9taXNlSGFuZGxlcihyZXEpXG4gICAgICAgIC50aGVuKFxuICAgICAgICAgIHJlc3VsdCA9PiB7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdC5yZXNwb25zZSAmJiAhcmVzdWx0LmxvY2F0aW9uICYmICFyZXN1bHQudGV4dCkge1xuICAgICAgICAgICAgICBsb2cuZXJyb3IoXG4gICAgICAgICAgICAgICAgJ3RoZSBoYW5kbGVyIGRpZCBub3QgaW5jbHVkZSBhIFwicmVzcG9uc2VcIiBvciBhIFwibG9jYXRpb25cIiBmaWVsZCdcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgdGhyb3cgJ2NvbnRyb2wgc2hvdWxkIG5vdCBnZXQgaGVyZSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxvZy5sb2dSZXNwb25zZSh7IG1ldGhvZCwgdXJsLCByZXN1bHQgfSk7XG5cbiAgICAgICAgICAgIHZhciBzdGF0dXMgPSByZXN1bHQuc3RhdHVzIHx8IDIwMDtcbiAgICAgICAgICAgIHJlcy5zdGF0dXMoc3RhdHVzKTtcblxuICAgICAgICAgICAgaWYgKHJlc3VsdC50ZXh0KSB7XG4gICAgICAgICAgICAgIHJlcy5zZW5kKHJlc3VsdC50ZXh0KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVzdWx0LmxvY2F0aW9uKSB7XG4gICAgICAgICAgICAgIHJlcy5zZXQoJ0xvY2F0aW9uJywgcmVzdWx0LmxvY2F0aW9uKTtcbiAgICAgICAgICAgICAgLy8gT3ZlcnJpZGUgdGhlIGRlZmF1bHQgZXhwcmVzc2pzIHJlc3BvbnNlXG4gICAgICAgICAgICAgIC8vIGFzIGl0IGRvdWJsZSBlbmNvZGVzICVlbmNvZGVkIGNoYXJzIGluIFVSTFxuICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5yZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHJlcy5zZW5kKCdGb3VuZC4gUmVkaXJlY3RpbmcgdG8gJyArIHJlc3VsdC5sb2NhdGlvbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0LmhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgT2JqZWN0LmtleXMocmVzdWx0LmhlYWRlcnMpLmZvckVhY2goaGVhZGVyID0+IHtcbiAgICAgICAgICAgICAgICByZXMuc2V0KGhlYWRlciwgcmVzdWx0LmhlYWRlcnNbaGVhZGVyXSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzLmpzb24ocmVzdWx0LnJlc3BvbnNlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVycm9yID0+IG5leHQoZXJyb3IpXG4gICAgICAgIClcbiAgICAgICAgLmNhdGNoKGUgPT4ge1xuICAgICAgICAgIGxvZy5lcnJvcihgRXJyb3IgZ2VuZXJhdGluZyByZXNwb25zZS4gJHtpbnNwZWN0KGUpfWAsIHsgZXJyb3I6IGUgfSk7XG4gICAgICAgICAgbmV4dChlKTtcbiAgICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nLmVycm9yKGBFcnJvciBoYW5kbGluZyByZXF1ZXN0OiAke2luc3BlY3QoZSl9YCwgeyBlcnJvcjogZSB9KTtcbiAgICAgIG5leHQoZSk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBtYXNrU2Vuc2l0aXZlVXJsKHJlcSkge1xuICBsZXQgbWFza1VybCA9IHJlcS5vcmlnaW5hbFVybC50b1N0cmluZygpO1xuICBjb25zdCBzaG91bGRNYXNrVXJsID1cbiAgICByZXEubWV0aG9kID09PSAnR0VUJyAmJlxuICAgIHJlcS5vcmlnaW5hbFVybC5pbmNsdWRlcygnL2xvZ2luJykgJiZcbiAgICAhcmVxLm9yaWdpbmFsVXJsLmluY2x1ZGVzKCdjbGFzc2VzJyk7XG4gIGlmIChzaG91bGRNYXNrVXJsKSB7XG4gICAgbWFza1VybCA9IGxvZy5tYXNrU2Vuc2l0aXZlVXJsKG1hc2tVcmwpO1xuICB9XG4gIHJldHVybiBtYXNrVXJsO1xufVxuIl19