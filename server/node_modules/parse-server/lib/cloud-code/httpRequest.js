"use strict";

var _HTTPResponse = _interopRequireDefault(require("./HTTPResponse"));

var _querystring = _interopRequireDefault(require("querystring"));

var _logger = _interopRequireDefault(require("../logger"));

var _followRedirects = require("follow-redirects");

var _url = require("url");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const clients = {
  'http:': _followRedirects.http,
  'https:': _followRedirects.https
};

function makeCallback(resolve, reject) {
  return function (response) {
    const chunks = [];
    response.on('data', chunk => {
      chunks.push(chunk);
    });
    response.on('end', () => {
      const body = Buffer.concat(chunks);
      const httpResponse = new _HTTPResponse.default(response, body); // Consider <200 && >= 400 as errors

      if (httpResponse.status < 200 || httpResponse.status >= 400) {
        return reject(httpResponse);
      } else {
        return resolve(httpResponse);
      }
    });
    response.on('error', reject);
  };
}

const encodeBody = function ({
  body,
  headers = {}
}) {
  if (typeof body !== 'object') {
    return {
      body,
      headers
    };
  }

  var contentTypeKeys = Object.keys(headers).filter(key => {
    return key.match(/content-type/i) != null;
  });

  if (contentTypeKeys.length == 0) {
    // no content type
    //  As per https://parse.com/docs/cloudcode/guide#cloud-code-advanced-sending-a-post-request the default encoding is supposedly x-www-form-urlencoded
    body = _querystring.default.stringify(body);
    headers['Content-Type'] = 'application/x-www-form-urlencoded';
  } else {
    /* istanbul ignore next */
    if (contentTypeKeys.length > 1) {
      _logger.default.error('Parse.Cloud.httpRequest', 'multiple content-type headers are set.');
    } // There maybe many, we'll just take the 1st one


    var contentType = contentTypeKeys[0];

    if (headers[contentType].match(/application\/json/i)) {
      body = JSON.stringify(body);
    } else if (headers[contentType].match(/application\/x-www-form-urlencoded/i)) {
      body = _querystring.default.stringify(body);
    }
  }

  return {
    body,
    headers
  };
};
/**
 * Makes an HTTP Request.
 *
 * **Available in Cloud Code only.**
 *
 * By default, Parse.Cloud.httpRequest does not follow redirects caused by HTTP 3xx response codes. You can use the followRedirects option in the {@link Parse.Cloud.HTTPOptions} object to change this behavior.
 *
 * Sample request:
 * ```
 * Parse.Cloud.httpRequest({
 *   url: 'http://www.parse.com/'
 * }).then(function(httpResponse) {
 *   // success
 *   console.log(httpResponse.text);
 * },function(httpResponse) {
 *   // error
 *   console.error('Request failed with response code ' + httpResponse.status);
 * });
 * ```
 *
 * @method httpRequest
 * @name Parse.Cloud.httpRequest
 * @param {Parse.Cloud.HTTPOptions} options The Parse.Cloud.HTTPOptions object that makes the request.
 * @return {Promise<Parse.Cloud.HTTPResponse>} A promise that will be resolved with a {@link Parse.Cloud.HTTPResponse} object when the request completes.
 */


module.exports = function httpRequest(options) {
  let url;

  try {
    url = (0, _url.parse)(options.url);
  } catch (e) {
    return Promise.reject(e);
  }

  options = Object.assign(options, encodeBody(options)); // support params options

  if (typeof options.params === 'object') {
    options.qs = options.params;
  } else if (typeof options.params === 'string') {
    options.qs = _querystring.default.parse(options.params);
  }

  const client = clients[url.protocol];

  if (!client) {
    return Promise.reject(`Unsupported protocol ${url.protocol}`);
  }

  const requestOptions = {
    method: options.method,
    port: Number(url.port),
    path: url.pathname,
    hostname: url.hostname,
    headers: options.headers,
    encoding: null,
    followRedirects: options.followRedirects === true
  };

  if (requestOptions.headers) {
    Object.keys(requestOptions.headers).forEach(key => {
      if (typeof requestOptions.headers[key] === 'undefined') {
        delete requestOptions.headers[key];
      }
    });
  }

  if (url.search) {
    options.qs = Object.assign({}, options.qs, _querystring.default.parse(url.query));
  }

  if (url.auth) {
    requestOptions.auth = url.auth;
  }

  if (options.qs) {
    requestOptions.path += `?${_querystring.default.stringify(options.qs)}`;
  }

  if (options.agent) {
    requestOptions.agent = options.agent;
  }

  return new Promise((resolve, reject) => {
    const req = client.request(requestOptions, makeCallback(resolve, reject, options));

    if (options.body) {
      req.write(options.body);
    }

    req.on('error', error => {
      reject(error);
    });
    req.end();
  });
};
/**
 * @typedef Parse.Cloud.HTTPOptions
 * @property {String|Object} body The body of the request. If it is a JSON object, then the Content-Type set in the headers must be application/x-www-form-urlencoded or application/json. You can also set this to a {@link Buffer} object to send raw bytes. If you use a Buffer, you should also set the Content-Type header explicitly to describe what these bytes represent.
 * @property {function} error The function that is called when the request fails. It will be passed a Parse.Cloud.HTTPResponse object.
 * @property {Boolean} followRedirects Whether to follow redirects caused by HTTP 3xx responses. Defaults to false.
 * @property {Object} headers The headers for the request.
 * @property {String} method The method of the request. GET, POST, PUT, DELETE, HEAD, and OPTIONS are supported. Will default to GET if not specified.
 * @property {String|Object} params The query portion of the url. You can pass a JSON object of key value pairs like params: {q : 'Sean Plott'} or a raw string like params:q=Sean Plott.
 * @property {function} success The function that is called when the request successfully completes. It will be passed a Parse.Cloud.HTTPResponse object.
 * @property {string} url The url to send the request to.
 */


module.exports.encodeBody = encodeBody;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jbG91ZC1jb2RlL2h0dHBSZXF1ZXN0LmpzIl0sIm5hbWVzIjpbImNsaWVudHMiLCJodHRwIiwiaHR0cHMiLCJtYWtlQ2FsbGJhY2siLCJyZXNvbHZlIiwicmVqZWN0IiwicmVzcG9uc2UiLCJjaHVua3MiLCJvbiIsImNodW5rIiwicHVzaCIsImJvZHkiLCJCdWZmZXIiLCJjb25jYXQiLCJodHRwUmVzcG9uc2UiLCJIVFRQUmVzcG9uc2UiLCJzdGF0dXMiLCJlbmNvZGVCb2R5IiwiaGVhZGVycyIsImNvbnRlbnRUeXBlS2V5cyIsIk9iamVjdCIsImtleXMiLCJmaWx0ZXIiLCJrZXkiLCJtYXRjaCIsImxlbmd0aCIsInF1ZXJ5c3RyaW5nIiwic3RyaW5naWZ5IiwibG9nIiwiZXJyb3IiLCJjb250ZW50VHlwZSIsIkpTT04iLCJtb2R1bGUiLCJleHBvcnRzIiwiaHR0cFJlcXVlc3QiLCJvcHRpb25zIiwidXJsIiwiZSIsIlByb21pc2UiLCJhc3NpZ24iLCJwYXJhbXMiLCJxcyIsInBhcnNlIiwiY2xpZW50IiwicHJvdG9jb2wiLCJyZXF1ZXN0T3B0aW9ucyIsIm1ldGhvZCIsInBvcnQiLCJOdW1iZXIiLCJwYXRoIiwicGF0aG5hbWUiLCJob3N0bmFtZSIsImVuY29kaW5nIiwiZm9sbG93UmVkaXJlY3RzIiwiZm9yRWFjaCIsInNlYXJjaCIsInF1ZXJ5IiwiYXV0aCIsImFnZW50IiwicmVxIiwicmVxdWVzdCIsIndyaXRlIiwiZW5kIl0sIm1hcHBpbmdzIjoiOztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7O0FBRUEsTUFBTUEsT0FBTyxHQUFHO0FBQ2QsV0FBU0MscUJBREs7QUFFZCxZQUFVQztBQUZJLENBQWhCOztBQUtBLFNBQVNDLFlBQVQsQ0FBc0JDLE9BQXRCLEVBQStCQyxNQUEvQixFQUF1QztBQUNyQyxTQUFPLFVBQVNDLFFBQVQsRUFBbUI7QUFDeEIsVUFBTUMsTUFBTSxHQUFHLEVBQWY7QUFDQUQsSUFBQUEsUUFBUSxD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RDs7QUFDRGdELElBQUFBLEdBQUcsQ0FBQ25ELEVBQUosQ0FBTyxPQUFQLEVBQWdCcUIsS0FBSyxJQUFJO0FBQ3ZCeEIsTUFBQUEsTUFBTSxDQUFDd0IsS0FBRCxDQUFOO0FBQ0QsS0FGRDtBQUdBOEIsSUFBQUEsR0FBRyxDQUFDRyxHQUFKO0FBQ0QsR0FaTSxDQUFQO0FBYUQsQ0EzREQ7QUE2REE7Ozs7Ozs7Ozs7Ozs7QUFZQTlCLE1BQU0sQ0FBQ0MsT0FBUCxDQUFlaEIsVUFBZixHQUE0QkEsVUFBNUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgSFRUUFJlc3BvbnNlIGZyb20gJy4vSFRUUFJlc3BvbnNlJztcbmltcG9ydCBxdWVyeXN0cmluZyBmcm9tICdxdWVyeXN0cmluZyc7XG5pbXBvcnQgbG9nIGZyb20gJy4uL2xvZ2dlcic7XG5pbXBvcnQgeyBodHRwLCBodHRwcyB9IGZyb20gJ2ZvbGxvdy1yZWRpcmVjdHMnO1xuaW1wb3J0IHsgcGFyc2UgfSBmcm9tICd1cmwnO1xuXG5jb25zdCBjbGllbnRzID0ge1xuICAnaHR0cDonOiBodHRwLFxuICAnaHR0cHM6JzogaHR0cHMsXG59O1xuXG5mdW5jdGlvbiBtYWtlQ2FsbGJhY2socmVzb2x2ZSwgcmVqZWN0KSB7XG4gIHJldHVybiBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgIGNvbnN0IGNodW5rcyA9IFtdO1xuICAgIHJlc3BvbnNlLm9uKCdkYXRhJywgY2h1bmsgPT4ge1xuICAgICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICAgIH0pO1xuICAgIHJlc3BvbnNlLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICBjb25zdCBib2R5ID0gQnVmZmVyLmNvbmNhdChjaHVua3MpO1xuICAgICAgY29uc3QgaHR0cFJlc3BvbnNlID0gbmV3IEhUVFBSZXNwb25zZShyZXNwb25zZSwgYm9keSk7XG5cbiAgICAgIC8vIENvbnNpZGVyIDwyMDAgJiYgPj0gNDAwIGFzIGVycm9yc1xuICAgICAgaWYgKGh0dHBSZXNwb25zZS5zdGF0dXMgPCAyMDAgfHwgaHR0cFJlc3BvbnNlLnN0YXR1cyA+PSA0MDApIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChodHRwUmVzcG9uc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoaHR0cFJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXNwb25zZS5vbignZXJyb3InLCByZWplY3QpO1xuICB9O1xufVxuXG5jb25zdCBlbmNvZGVCb2R5ID0gZnVuY3Rpb24oeyBib2R5LCBoZWFkZXJzID0ge30gfSkge1xuICBpZiAodHlwZW9mIGJvZHkgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIHsgYm9keSwgaGVhZGVycyB9O1xuICB9XG4gIHZhciBjb250ZW50VHlwZUtleXMgPSBPYmplY3Qua2V5cyhoZWFkZXJzKS5maWx0ZXIoa2V5ID0+IHtcbiAgICByZXR1cm4ga2V5Lm1hdGNoKC9jb250ZW50LXR5cGUvaSkgIT0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKGNvbnRlbnRUeXBlS2V5cy5sZW5ndGggPT0gMCkge1xuICAgIC8vIG5vIGNvbnRlbnQgdHlwZVxuICAgIC8vICBBcyBwZXIgaHR0cHM6Ly9wYXJzZS5jb20vZG9jcy9jbG91ZGNvZGUvZ3VpZGUjY2xvdWQtY29kZS1hZHZhbmNlZC1zZW5kaW5nLWEtcG9zdC1yZXF1ZXN0IHRoZSBkZWZhdWx0IGVuY29kaW5nIGlzIHN1cHBvc2VkbHkgeC13d3ctZm9ybS11cmxlbmNvZGVkXG5cbiAgICBib2R5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KGJvZHkpO1xuICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc7XG4gIH0gZWxzZSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAoY29udGVudFR5cGVLZXlzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGxvZy5lcnJvcihcbiAgICAgICAgJ1BhcnNlLkNsb3VkLmh0dHBSZXF1ZXN0JyxcbiAgICAgICAgJ211bHRpcGxlIGNvbnRlbnQtdHlwZSBoZWFkZXJzIGFyZSBzZXQuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgLy8gVGhlcmUgbWF5YmUgbWFueSwgd2UnbGwganVzdCB0YWtlIHRoZSAxc3Qgb25lXG4gICAgdmFyIGNvbnRlbnRUeXBlID0gY29udGVudFR5cGVLZXlzWzBdO1xuICAgIGlmIChoZWFkZXJzW2NvbnRlbnRUeXBlXS5tYXRjaCgvYXBwbGljYXRpb25cXC9qc29uL2kpKSB7XG4gICAgICBib2R5ID0gSlNPTi5zdHJpbmdpZnkoYm9keSk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGhlYWRlcnNbY29udGVudFR5cGVdLm1hdGNoKC9hcHBsaWNhdGlvblxcL3gtd3d3LWZvcm0tdXJsZW5jb2RlZC9pKVxuICAgICkge1xuICAgICAgYm9keSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeShib2R5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgYm9keSwgaGVhZGVycyB9O1xufTtcblxuLyoqXG4gKiBNYWtlcyBhbiBIVFRQIFJlcXVlc3QuXG4gKlxuICogKipBdmFpbGFibGUgaW4gQ2xvdWQgQ29kZSBvbmx5LioqXG4gKlxuICogQnkgZGVmYXVsdCwgUGFyc2UuQ2xvdWQuaHR0cFJlcXVlc3QgZG9lcyBub3QgZm9sbG93IHJlZGlyZWN0cyBjYXVzZWQgYnkgSFRUUCAzeHggcmVzcG9uc2UgY29kZXMuIFlvdSBjYW4gdXNlIHRoZSBmb2xsb3dSZWRpcmVjdHMgb3B0aW9uIGluIHRoZSB7QGxpbmsgUGFyc2UuQ2xvdWQuSFRUUE9wdGlvbnN9IG9iamVjdCB0byBjaGFuZ2UgdGhpcyBiZWhhdmlvci5cbiAqXG4gKiBTYW1wbGUgcmVxdWVzdDpcbiAqIGBgYFxuICogUGFyc2UuQ2xvdWQuaHR0cFJlcXVlc3Qoe1xuICogICB1cmw6ICdodHRwOi8vd3d3LnBhcnNlLmNvbS8nXG4gKiB9KS50aGVuKGZ1bmN0aW9uKGh0dHBSZXNwb25zZSkge1xuICogICAvLyBzdWNjZXNzXG4gKiAgIGNvbnNvbGUubG9nKGh0dHBSZXNwb25zZS50ZXh0KTtcbiAqIH0sZnVuY3Rpb24oaHR0cFJlc3BvbnNlKSB7XG4gKiAgIC8vIGVycm9yXG4gKiAgIGNvbnNvbGUuZXJyb3IoJ1JlcXVlc3QgZmFpbGVkIHdpdGggcmVzcG9uc2UgY29kZSAnICsgaHR0cFJlc3BvbnNlLnN0YXR1cyk7XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBtZXRob2QgaHR0cFJlcXVlc3RcbiAqIEBuYW1lIFBhcnNlLkNsb3VkLmh0dHBSZXF1ZXN0XG4gKiBAcGFyYW0ge1BhcnNlLkNsb3VkLkhUVFBPcHRpb25zfSBvcHRpb25zIFRoZSBQYXJzZS5DbG91ZC5IVFRQT3B0aW9ucyBvYmplY3QgdGhhdCBtYWtlcyB0aGUgcmVxdWVzdC5cbiAqIEByZXR1cm4ge1Byb21pc2U8UGFyc2UuQ2xvdWQuSFRUUFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZCB3aXRoIGEge0BsaW5rIFBhcnNlLkNsb3VkLkhUVFBSZXNwb25zZX0gb2JqZWN0IHdoZW4gdGhlIHJlcXVlc3QgY29tcGxldGVzLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGh0dHBSZXF1ZXN0KG9wdGlvbnMpIHtcbiAgbGV0IHVybDtcbiAgdHJ5IHtcbiAgICB1cmwgPSBwYXJzZShvcHRpb25zLnVybCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gIH1cbiAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24ob3B0aW9ucywgZW5jb2RlQm9keShvcHRpb25zKSk7XG4gIC8vIHN1cHBvcnQgcGFyYW1zIG9wdGlvbnNcbiAgaWYgKHR5cGVvZiBvcHRpb25zLnBhcmFtcyA9PT0gJ29iamVjdCcpIHtcbiAgICBvcHRpb25zLnFzID0gb3B0aW9ucy5wYXJhbXM7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMucGFyYW1zID09PSAnc3RyaW5nJykge1xuICAgIG9wdGlvbnMucXMgPSBxdWVyeXN0cmluZy5wYXJzZShvcHRpb25zLnBhcmFtcyk7XG4gIH1cbiAgY29uc3QgY2xpZW50ID0gY2xpZW50c1t1cmwucHJvdG9jb2xdO1xuICBpZiAoIWNsaWVudCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChgVW5zdXBwb3J0ZWQgcHJvdG9jb2wgJHt1cmwucHJvdG9jb2x9YCk7XG4gIH1cbiAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgbWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcbiAgICBwb3J0OiBOdW1iZXIodXJsLnBvcnQpLFxuICAgIHBhdGg6IHVybC5wYXRobmFtZSxcbiAgICBob3N0bmFtZTogdXJsLmhvc3RuYW1lLFxuICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVycyxcbiAgICBlbmNvZGluZzogbnVsbCxcbiAgICBmb2xsb3dSZWRpcmVjdHM6IG9wdGlvbnMuZm9sbG93UmVkaXJlY3RzID09PSB0cnVlLFxuICB9O1xuICBpZiAocmVxdWVzdE9wdGlvbnMuaGVhZGVycykge1xuICAgIE9iamVjdC5rZXlzKHJlcXVlc3RPcHRpb25zLmhlYWRlcnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmICh0eXBlb2YgcmVxdWVzdE9wdGlvbnMuaGVhZGVyc1trZXldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBkZWxldGUgcmVxdWVzdE9wdGlvbnMuaGVhZGVyc1trZXldO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGlmICh1cmwuc2VhcmNoKSB7XG4gICAgb3B0aW9ucy5xcyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMucXMsIHF1ZXJ5c3RyaW5nLnBhcnNlKHVybC5xdWVyeSkpO1xuICB9XG4gIGlmICh1cmwuYXV0aCkge1xuICAgIHJlcXVlc3RPcHRpb25zLmF1dGggPSB1cmwuYXV0aDtcbiAgfVxuICBpZiAob3B0aW9ucy5xcykge1xuICAgIHJlcXVlc3RPcHRpb25zLnBhdGggKz0gYD8ke3F1ZXJ5c3RyaW5nLnN0cmluZ2lmeShvcHRpb25zLnFzKX1gO1xuICB9XG4gIGlmIChvcHRpb25zLmFnZW50KSB7XG4gICAgcmVxdWVzdE9wdGlvbnMuYWdlbnQgPSBvcHRpb25zLmFnZW50O1xuICB9XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgcmVxID0gY2xpZW50LnJlcXVlc3QoXG4gICAgICByZXF1ZXN0T3B0aW9ucyxcbiAgICAgIG1ha2VDYWxsYmFjayhyZXNvbHZlLCByZWplY3QsIG9wdGlvbnMpXG4gICAgKTtcbiAgICBpZiAob3B0aW9ucy5ib2R5KSB7XG4gICAgICByZXEud3JpdGUob3B0aW9ucy5ib2R5KTtcbiAgICB9XG4gICAgcmVxLm9uKCdlcnJvcicsIGVycm9yID0+IHtcbiAgICAgIHJlamVjdChlcnJvcik7XG4gICAgfSk7XG4gICAgcmVxLmVuZCgpO1xuICB9KTtcbn07XG5cbi8qKlxuICogQHR5cGVkZWYgUGFyc2UuQ2xvdWQuSFRUUE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfE9iamVjdH0gYm9keSBUaGUgYm9keSBvZiB0aGUgcmVxdWVzdC4gSWYgaXQgaXMgYSBKU09OIG9iamVjdCwgdGhlbiB0aGUgQ29udGVudC1UeXBlIHNldCBpbiB0aGUgaGVhZGVycyBtdXN0IGJlIGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCBvciBhcHBsaWNhdGlvbi9qc29uLiBZb3UgY2FuIGFsc28gc2V0IHRoaXMgdG8gYSB7QGxpbmsgQnVmZmVyfSBvYmplY3QgdG8gc2VuZCByYXcgYnl0ZXMuIElmIHlvdSB1c2UgYSBCdWZmZXIsIHlvdSBzaG91bGQgYWxzbyBzZXQgdGhlIENvbnRlbnQtVHlwZSBoZWFkZXIgZXhwbGljaXRseSB0byBkZXNjcmliZSB3aGF0IHRoZXNlIGJ5dGVzIHJlcHJlc2VudC5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IGVycm9yIFRoZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSByZXF1ZXN0IGZhaWxzLiBJdCB3aWxsIGJlIHBhc3NlZCBhIFBhcnNlLkNsb3VkLkhUVFBSZXNwb25zZSBvYmplY3QuXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGZvbGxvd1JlZGlyZWN0cyBXaGV0aGVyIHRvIGZvbGxvdyByZWRpcmVjdHMgY2F1c2VkIGJ5IEhUVFAgM3h4IHJlc3BvbnNlcy4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gKiBAcHJvcGVydHkge09iamVjdH0gaGVhZGVycyBUaGUgaGVhZGVycyBmb3IgdGhlIHJlcXVlc3QuXG4gKiBAcHJvcGVydHkge1N0cmluZ30gbWV0aG9kIFRoZSBtZXRob2Qgb2YgdGhlIHJlcXVlc3QuIEdFVCwgUE9TVCwgUFVULCBERUxFVEUsIEhFQUQsIGFuZCBPUFRJT05TIGFyZSBzdXBwb3J0ZWQuIFdpbGwgZGVmYXVsdCB0byBHRVQgaWYgbm90IHNwZWNpZmllZC5cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfE9iamVjdH0gcGFyYW1zIFRoZSBxdWVyeSBwb3J0aW9uIG9mIHRoZSB1cmwuIFlvdSBjYW4gcGFzcyBhIEpTT04gb2JqZWN0IG9mIGtleSB2YWx1ZSBwYWlycyBsaWtlIHBhcmFtczoge3EgOiAnU2VhbiBQbG90dCd9IG9yIGEgcmF3IHN0cmluZyBsaWtlIHBhcmFtczpxPVNlYW4gUGxvdHQuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBzdWNjZXNzIFRoZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSByZXF1ZXN0IHN1Y2Nlc3NmdWxseSBjb21wbGV0ZXMuIEl0IHdpbGwgYmUgcGFzc2VkIGEgUGFyc2UuQ2xvdWQuSFRUUFJlc3BvbnNlIG9iamVjdC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB1cmwgVGhlIHVybCB0byBzZW5kIHRoZSByZXF1ZXN0IHRvLlxuICovXG5cbm1vZHVsZS5leHBvcnRzLmVuY29kZUJvZHkgPSBlbmNvZGVCb2R5O1xuIl19