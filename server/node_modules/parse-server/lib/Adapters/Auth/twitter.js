"use strict";

// Helper functions for accessing the twitter API.
var OAuth = require('./OAuth1Client');

var Parse = require('parse/node').Parse;

var logger = require('../../logger').default; // Returns a promise that fulfills iff this user id is valid.


function validateAuthData(authData, options) {
  if (!options) {
    throw new Parse.Error(Parse.Error.INTERNAL_SERVER_ERROR, 'Twitter auth configuration missing');
  }

  options = handleMultipleConfigurations(authData, options);
  var client = new OAuth(options);
  client.host = 'api.twitter.com';
  client.auth_token = authData.auth_token;
  client.auth_token_secret = authData.auth_token_secret;
  return client.get('/1.1/account/verify_credentials.json').then(data => {
    if (data && data.id_str == '' + authData.id) {
      return;
    }

    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Twitter auth is invalid for this user.');
  });
} // Returns a promise that fulfills iff this app id is valid.


function validateAppId() {
  return Promise.resolve();
}

function handleMultipleConfigurations(authData, options) {
  if (Array.isArray(options)) {
    const consumer_key = authData.consumer_key;

    if (!consumer_key) {
      logger.error('Twitter Auth', 'Multiple twitter configurations are available, by no consumer_key was sent by the client.');
      throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Twitter auth is invalid for this user.');
    }

    options = options.filter(option => {
      return option.consumer_key == consumer_key;
    });

    if (options.length == 0) {
      logger.error('Twitter Auth', 'Cannot find a configuration for the provided consumer_key');
      throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Twitter auth is invalid for this user.');
    }

    options = options[0];
  }

  return options;
}

module.exports = {
  validateAppId,
  validateAuthData,
  handleMultipleConfigurations
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9BZGFwdGVycy9BdXRoL3R3aXR0ZXIuanMiXSwibmFtZXMiOlsiT0F1dGgiLCJyZXF1aXJlIiwiUGFyc2UiLCJsb2dnZXIiLCJkZWZhdWx0IiwidmFsaWRhdGVBdXRoRGF0YSIsImF1dGhEYXRhIiwib3B0aW9ucyIsIkVycm9yIiwiSU5URVJOQUxfU0VSVkVSX0VSUk9SIiwiaGFuZGxlTXVsdGlwbGVDb25maWd1cmF0aW9ucyIsImNsaWVudCIsImhvc3QiLCJhdXRoX3Rva2VuIiwiYXV0aF90b2tlbl9zZWNyZXQiLCJnZXQiLCJ0aGVuIiwiZGF0YSIsImlkX3N0ciIsImlkIiwiT0JKRUNUX05PVF9GT1VORCIsInZhbGlkYXRlQXBwSWQiLCJQcm9taXNlIiwicmVzb2x2ZSIsIkFycmF5IiwiaXNBcnJheSIsImNvbnN1bWVyX2tleSIsImVycm9yIiwiZmlsdGVyIiwib3B0aW9uIiwibGVuZ3RoIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBLElBQUlBLEtBQUssR0FBR0MsT0FBTyxDQUFDLGdCQUFELENBQW5COztBQUNBLElBQUlDLEtBQUssR0FBR0QsT0FBTyxDQUFDLFlBQUQsQ0FBUCxDQUFzQkMsS0FBbEM7O0FBQ0EsSUFBSUMsTUFBTSxHQUFHRixPQUFPLENBQUMsY0FBRCxDQUFQLENBQXdCRyxPQUFyQyxDLENBRUE7OztBQUNBLFNBQVNDLGdCQUFULENBQTBCQyxRQUExQixFQUFvQ0MsT0FBcEMsRUFBNkM7QUFDM0MsTUFBSSxDQUFDQSxPQUFMLEVBQWM7QUFDWixVQUFNLElBQUlMLEtBQUssQ0FBQ00sS0FBVixDQUNKTixLQUFLLENBQUNNLEtBQU4sQ0FBWUMscUJBRFIsRUFFSixvQ0FGSSxDQUFOO0FBSUQ7O0FBQ0RGLEVBQUFBLE9BQU8sR0FBR0csNEJBQTRCLENBQUNKLFFBQUQsRUFBV0MsT0FBWCxDQUF0QztBQUNBLE1BQUlJLE1BQU0sR0FBRyxJQUFJWCxLQUFKLENBQVVPLE9BQVYsQ0FBYjtBQUNBSSxFQUFBQSxNQUFNLENBQUNDLElBQVAsR0FBYyxpQkFBZDtBQUNBRCxFQUFBQSxNQUFNLENBQUNFLFVBQVAsR0FBb0JQLFFBQVEsQ0FBQ08sVUFBN0I7QUFDQUYsRUFBQUEsTUFBTSxDQUFDRyxpQkFBUCxHQUEyQlIsUUFBUSxDQUFDUSxpQkFBcEM7QUFFQSxTQUFPSCxNQUFNLENBQUNJLEdBQVAsQ0FBVyxzQ0FBWCxFQUFtREMsSUFBbkQsQ0FBd0RDLElBQUksSUFBSTtBQUNyRSxRQUFJQSxJQUFJLElBQUlBLElBQUksQ0FBQ0MsTUFBTCxJQUFlLEtBQUtaLFFBQVEsQ0FBQ2EsRUFBekMsRUFBNkM7QUFDM0M7QUFDRDs7QUFDRCxVQUFNLElBQUlqQixLQUFLLENBQUNNLEtBQVYsQ0FDSk4sS0FBSyxDQUFDTSxLQUFOLENBQVlZLGdCQURSLEVBRUosd0NBRkksQ0FBTjtBQUlELEdBUk0sQ0FBUDtBQVNELEMsQ0FFRDs7O0FBQ0EsU0FBU0MsYUFBVCxHQUF5QjtBQUN2QixTQUFPQyxPQUFPLENBQUNDLE9BQVIsRUFBUDtBQUNEOztBQUVELFNBQVNiLDRCQUFULENBQXNDSixRQUF0QyxFQUFnREMsT0FBaEQsRUFBeUQ7QUFDdkQsTUFBSWlCLEtBQUssQ0FBQ0MsT0FBTixDQUFjbEIsT0FBZCxDQUFKLEVBQTRCO0FBQzFCLFVBQU1tQixZQUFZLEdBQUdwQixRQUFRLENBQUNvQixZQUE5Qjs7QUFDQSxRQUFJLENBQUNBLFlBQUwsRUFBbUI7QUFDakJ2QixNQUFBQSxNQUFNLENBQUN3QixLQUFQLENBQ0UsY0FERixFQUVFLDJGQUZGO0FBSUEsWUFBTSxJQUFJekIsS0FBSyxDQUFDTSxLQUFWLENBQ0pOLEtBQUssQ0FBQ00sS0FBTixDQUFZWSxnQkFEUixFQUVKLHdDQUZJLENBQU47QUFJRDs7QUFDRGIsSUFBQUEsT0FBTyxHQUFHQSxPQUFPLENBQUNxQixNQUFSLENBQWVDLE1BQU0sSUFBSTtBQUNqQyxhQUFPQSxNQUFNLENBQUNILFlBQVAsSUFBdUJBLFlBQTlCO0FBQ0QsS0FGUyxDQUFWOztBQUlBLFFBQUluQixPQUFPLENBQUN1QixNQUFSLElBQWtCLENBQXRCLEVBQXlCO0FBQ3ZCM0IsTUFBQUEsTUFBTSxDQUFDd0IsS0FBUCxDQUNFLGNBREYsRUFFRSwyREFGRjtBQUlBLFlBQU0sSUFBSXpCLEtBQUssQ0FBQ00sS0FBVixDQUNKTixLQUFLLENBQUNNLEtBQU4sQ0FBWVksZ0JBRFIsRUFFSix3Q0FGSSxDQUFOO0FBSUQ7O0FBQ0RiLElBQUFBLE9BQU8sR0FBR0EsT0FBTyxDQUFDLENBQUQsQ0FBakI7QUFDRDs7QUFDRCxTQUFPQSxPQUFQO0FBQ0Q7O0FBRUR3QixNQUFNLENBQUNDLE9BQVAsR0FBaUI7QUFDZlgsRUFBQUEsYUFEZTtBQUVmaEIsRUFBQUEsZ0JBRmU7QUFHZkssRUFBQUE7QUFIZSxDQUFqQiIsInNvdXJjZXNDb250ZW50IjpbIi8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIGFjY2Vzc2luZyB0aGUgdHdpdHRlciBBUEkuXG52YXIgT0F1dGggPSByZXF1aXJlKCcuL09BdXRoMUNsaWVudCcpO1xudmFyIFBhcnNlID0gcmVxdWlyZSgncGFyc2Uvbm9kZScpLlBhcnNlO1xudmFyIGxvZ2dlciA9IHJlcXVpcmUoJy4uLy4uL2xvZ2dlcicpLmRlZmF1bHQ7XG5cbi8vIFJldHVybnMgYSBwcm9taXNlIHRoYXQgZnVsZmlsbHMgaWZmIHRoaXMgdXNlciBpZCBpcyB2YWxpZC5cbmZ1bmN0aW9uIHZhbGlkYXRlQXV0aERhdGEoYXV0aERhdGEsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgdGhyb3cgbmV3IFBhcnNlLkVycm9yKFxuICAgICAgUGFyc2UuRXJyb3IuSU5URVJOQUxfU0VSVkVSX0VSUk9SLFxuICAgICAgJ1R3aXR0ZXIgYXV0aCBjb25maWd1cmF0aW9uIG1pc3NpbmcnXG4gICAgKTtcbiAgfVxuICBvcHRpb25zID0gaGFuZGxlTXVsdGlwbGVDb25maWd1cmF0aW9ucyhhdXRoRGF0YSwgb3B0aW9ucyk7XG4gIHZhciBjbGllbnQgPSBuZXcgT0F1dGgob3B0aW9ucyk7XG4gIGNsaWVudC5ob3N0ID0gJ2FwaS50d2l0dGVyLmNvbSc7XG4gIGNsaWVudC5hdXRoX3Rva2VuID0gYXV0aERhdGEuYXV0aF90b2tlbjtcbiAgY2xpZW50LmF1dGhfdG9rZW5fc2VjcmV0ID0gYXV0aERhdGEuYXV0aF90b2tlbl9zZWNyZXQ7XG5cbiAgcmV0dXJuIGNsaWVudC5nZXQoJy8xLjEvYWNjb3VudC92ZXJpZnlfY3JlZGVudGlhbHMuanNvbicpLnRoZW4oZGF0YSA9PiB7XG4gICAgaWYgKGRhdGEgJiYgZGF0YS5pZF9zdHIgPT0gJycgKyBhdXRoRGF0YS5pZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgUGFyc2UuRXJyb3IoXG4gICAgICBQYXJzZS5FcnJvci5PQkpFQ1RfTk9UX0ZPVU5ELFxuICAgICAgJ1R3aXR0ZXIgYXV0aCBpcyBpbnZhbGlkIGZvciB0aGlzIHVzZXIuJ1xuICAgICk7XG4gIH0pO1xufVxuXG4vLyBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IGZ1bGZpbGxzIGlmZiB0aGlzIGFwcCBpZCBpcyB2YWxpZC5cbmZ1bmN0aW9uIHZhbGlkYXRlQXBwSWQoKSB7XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlTXVsdGlwbGVDb25maWd1cmF0aW9ucyhhdXRoRGF0YSwgb3B0aW9ucykge1xuICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgIGNvbnN0IGNvbnN1bWVyX2tleSA9IGF1dGhEYXRhLmNvbnN1bWVyX2tleTtcbiAgICBpZiAoIWNvbnN1bWVyX2tleSkge1xuICAgICAgbG9nZ2VyLmVycm9yKFxuICAgICAgICAnVHdpdHRlciBBdXRoJyxcbiAgICAgICAgJ011bHRpcGxlIHR3aXR0ZXIgY29uZmlndXJhdGlvbnMgYXJlIGF2YWlsYWJsZSwgYnkgbm8gY29uc3VtZXJfa2V5IHdhcyBzZW50IGJ5IHRoZSBjbGllbnQuJ1xuICAgICAgKTtcbiAgICAgIHRocm93IG5ldyBQYXJzZS5FcnJvcihcbiAgICAgICAgUGFyc2UuRXJyb3IuT0JKRUNUX05PVF9GT1VORCxcbiAgICAgICAgJ1R3aXR0ZXIgYXV0aCBpcyBpbnZhbGlkIGZvciB0aGlzIHVzZXIuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMuZmlsdGVyKG9wdGlvbiA9PiB7XG4gICAgICByZXR1cm4gb3B0aW9uLmNvbnN1bWVyX2tleSA9PSBjb25zdW1lcl9rZXk7XG4gICAgfSk7XG5cbiAgICBpZiAob3B0aW9ucy5sZW5ndGggPT0gMCkge1xuICAgICAgbG9nZ2VyLmVycm9yKFxuICAgICAgICAnVHdpdHRlciBBdXRoJyxcbiAgICAgICAgJ0Nhbm5vdCBmaW5kIGEgY29uZmlndXJhdGlvbiBmb3IgdGhlIHByb3ZpZGVkIGNvbnN1bWVyX2tleSdcbiAgICAgICk7XG4gICAgICB0aHJvdyBuZXcgUGFyc2UuRXJyb3IoXG4gICAgICAgIFBhcnNlLkVycm9yLk9CSkVDVF9OT1RfRk9VTkQsXG4gICAgICAgICdUd2l0dGVyIGF1dGggaXMgaW52YWxpZCBmb3IgdGhpcyB1c2VyLidcbiAgICAgICk7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zWzBdO1xuICB9XG4gIHJldHVybiBvcHRpb25zO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdmFsaWRhdGVBcHBJZCxcbiAgdmFsaWRhdGVBdXRoRGF0YSxcbiAgaGFuZGxlTXVsdGlwbGVDb25maWd1cmF0aW9ucyxcbn07XG4iXX0=