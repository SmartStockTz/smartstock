import { __decorate, __metadata, __extends } from 'tslib';
import 'localforage';
import { InjectionToken, NgModule, Inject, Injectable, Optional, defineInjectable, inject } from '@angular/core';
import { LazyGetter } from 'typescript-lazy-get-decorator';

var lf = require('localforage');
var localForage = 'defineDriver' in lf ? lf : lf.default;
var serializer$ = require('localforage/src/utils/serializer');
var serializer = serializer$.default || serializer$;
function _getKeyPrefix(options, defaultConfig) {
    var keyPrefix = options.name + "/";
    if (options.storeName !== defaultConfig.storeName) {
        keyPrefix += options.storeName + "/";
    }
    return keyPrefix;
}
function checkIfSessionStorageThrows() {
    var testKey = '_localforage_support_test';
    try {
        sessionStorage.setItem(testKey, '1');
        sessionStorage.removeItem(testKey);
        return false;
    }
    catch (e) {
        return true;
    }
}
function _isSessionStorageUsable() {
    return typeof sessionStorage !== 'undefined' && (!checkIfSessionStorageThrows() || sessionStorage.length > 0);
}
function _initStorage(options) {
    var dbInfo = {};
    if (options) {
        for (var i in options) {
            dbInfo[i] = options[i];
        }
    }
    dbInfo.keyPrefix = _getKeyPrefix(options, this._defaultConfig);
    if (!_isSessionStorageUsable()) {
        return Promise.reject(new Error('Local storage unusable'));
    }
    this._dbInfo = dbInfo;
    dbInfo.serializer = serializer;
    return Promise.resolve();
}
function executeCallback(promise, callback) {
    if (callback) {
        promise.then(function (result) {
            callback(null, result);
        }, function (error) {
            callback(error);
        });
    }
}
function clear(callback) {
    var _this = this;
    var promise = this.ready().then(function () {
        var keyPrefix = _this._dbInfo.keyPrefix;
        for (var i = sessionStorage.length - 1; i >= 0; i--) {
            var key$ = sessionStorage.key(i);
            if (key$ !== null && key$.indexOf(keyPrefix) === 0) {
                sessionStorage.removeItem(key$);
            }
        }
    });
    executeCallback(promise, callback);
    return promise;
}
function getCallback() {
    if (arguments.length && typeof arguments[arguments.length - 1] === 'function') {
        return arguments[arguments.length - 1];
    }
}
function dropInstance(options, callback) {
    var _this = this;
    callback = getCallback.apply(this, arguments);
    options = (typeof options !== 'function' && options) || {};
    if (!options.name) {
        var currentConfig = this.config();
        options.name = options.name || currentConfig.name;
        options.storeName = options.storeName || currentConfig.storeName;
    }
    var promise;
    if (!options.name) {
        promise = Promise.reject('Invalid arguments');
    }
    else {
        promise = new Promise(function (resolve) {
            if (!options.storeName) {
                resolve(options.name + "/");
            }
            else {
                resolve(_getKeyPrefix(options, _this._defaultConfig));
            }
        })
            .then(function (keyPrefix) {
            for (var i = sessionStorage.length - 1; i >= 0; i--) {
                var key$ = sessionStorage.key(i);
                if (key$ !== null && key$.indexOf(keyPrefix) === 0) {
                    sessionStorage.removeItem(key$);
                }
            }
        });
    }
    executeCallback(promise, callback);
    return promise;
}
function normalizeKey(key) {
    if (typeof key !== 'string') {
        console.warn(key + " used as a key, but it is not a string.");
        key = String(key);
    }
    return key;
}
function getItem(key$, callback) {
    var _this = this;
    key$ = normalizeKey(key$);
    var promise = this.ready().then(function () {
        var result = sessionStorage.getItem("" + _this._dbInfo.keyPrefix + key$);
        if (result) {
            result = _this._dbInfo.serializer.deserialize(result);
        }
        return result;
    });
    executeCallback(promise, callback);
    return promise;
}
function iterate(iterator, callback) {
    var _this = this;
    var promise = this.ready().then(function () {
        var keyPrefix = _this._dbInfo.keyPrefix;
        var keyPrefixLength = keyPrefix.length;
        var length$ = sessionStorage.length;
        var iterationNumber = 1;
        for (var i = 0; i < length$; i++) {
            var key$ = sessionStorage.key(i);
            if (key$ === null || key$.indexOf(keyPrefix) !== 0) {
                continue;
            }
            var value = sessionStorage.getItem(key$);
            if (value) {
                value = _this._dbInfo.serializer.deserialize(value);
            }
            value = iterator(value, key$.substring(keyPrefixLength), iterationNumber++);
            if (value !== void 0) {
                return value;
            }
        }
    });
    executeCallback(promise, callback);
    return promise;
}
function key(n, callback) {
    var _this = this;
    var promise = this.ready().then(function () {
        var result;
        try {
            result = sessionStorage.key(n);
        }
        catch (error) {
            result = null;
        }
        if (result) {
            result = result.substring(_this._dbInfo.keyPrefix.length);
        }
        return result;
    });
    executeCallback(promise, callback);
    return promise;
}
function keys(callback) {
    var _this = this;
    var promise = this.ready().then(function () {
        var length$ = sessionStorage.length;
        var keys$ = [];
        for (var i = 0; i < length$; i++) {
            var itemKey = sessionStorage.key(i);
            if (itemKey !== null && itemKey.indexOf(_this._dbInfo.keyPrefix) === 0) {
                keys$.push(itemKey.substring(_this._dbInfo.keyPrefix.length));
            }
        }
        return keys$;
    });
    executeCallback(promise, callback);
    return promise;
}
function length(callback) {
    var promise = this.keys().then(function (keys$) { return keys$.length; });
    executeCallback(promise, callback);
    return promise;
}
function removeItem(key$, callback) {
    var _this = this;
    key$ = normalizeKey(key$);
    var promise = this.ready().then(function () {
        sessionStorage.removeItem("" + _this._dbInfo.keyPrefix + key$);
    });
    executeCallback(promise, callback);
    return promise;
}
function setItem(key$, value, callback) {
    var _this = this;
    key$ = normalizeKey(key$);
    var promise = this.ready().then(function () {
        if (value === undefined) {
            value = null;
        }
        var originalValue = value;
        return new Promise(function (resolve, reject) {
            _this._dbInfo.serializer.serialize(value, function (value$, error) {
                if (error) {
                    reject(error);
                }
                else {
                    try {
                        sessionStorage.setItem("" + _this._dbInfo.keyPrefix + key$, value$);
                        resolve(originalValue);
                    }
                    catch (e) {
                        if (e.name === 'QuotaExceededError' ||
                            e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {
                            reject(e);
                        }
                        reject(e);
                    }
                }
            });
        });
    });
    executeCallback(promise, callback);
    return promise;
}
var _driver = 'ngforage_sessionStorage';
var sessionStorageWrapper = {
    _driver: _driver,
    _initStorage: _initStorage,
    _support: _isSessionStorageUsable(),
    clear: clear,
    dropInstance: dropInstance,
    getItem: getItem,
    iterate: iterate,
    key: key,
    keys: keys,
    length: length,
    removeItem: removeItem,
    setItem: setItem
};
localForage.defineDriver(sessionStorageWrapper).catch(console.error);
var DEFAULT_CONFIG = new InjectionToken('Default NgForage config');
var NgForageModule = /** @class */ (function () {
    function NgForageModule() {
    }
    NgForageModule.forRoot = function (config) {
        if (config === void 0) { config = {}; }
        return {
            ngModule: NgForageModule,
            providers: [
                {
                    provide: DEFAULT_CONFIG,
                    useValue: Object.assign({}, config)
                }
            ]
        };
    };
    return NgForageModule;
}());
NgForageModule.decorators = [
    { type: NgModule, args: [{},] },
];
var $defaultConfig = Symbol('Default Config');
var NgForageConfig = /** @class */ (function () {
    function NgForageConfig(conf) {
        this[$defaultConfig] = {
            cacheTime: 300000,
            description: '',
            driver: [localForage.INDEXEDDB, localForage.WEBSQL, localForage.LOCALSTORAGE],
            name: 'ngForage',
            size: 4980736,
            storeName: 'ng_forage',
            version: 1
        };
        if (conf) {
            this.configure(conf);
        }
    }
    Object.defineProperty(NgForageConfig.prototype, "cacheTime", {
        get: function () {
            return this[$defaultConfig].cacheTime;
        },
        set: function (t) {
            this[$defaultConfig].cacheTime = t;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgForageConfig.prototype, "config", {
        get: function () {
            return {
                cacheTime: this.cacheTime,
                description: this.description,
                driver: this.driver,
                name: this.name,
                size: this.size,
                storeName: this.storeName,
                version: this.version
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgForageConfig.prototype, "description", {
        get: function () {
            return this[$defaultConfig].description;
        },
        set: function (v) {
            this[$defaultConfig].description = v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgForageConfig.prototype, "driver", {
        get: function () {
            if (typeof this[$defaultConfig].driver === 'string') {
                return this[$defaultConfig].driver;
            }
            return this[$defaultConfig].driver.slice();
        },
        set: function (v) {
            this[$defaultConfig].driver = v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgForageConfig.prototype, "name", {
        get: function () {
            return this[$defaultConfig].name;
        },
        set: function (v) {
            this[$defaultConfig].name = v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgForageConfig.prototype, "size", {
        get: function () {
            return this[$defaultConfig].size;
        },
        set: function (v) {
            this[$defaultConfig].size = v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgForageConfig.prototype, "storeName", {
        get: function () {
            return this[$defaultConfig].storeName;
        },
        set: function (v) {
            this[$defaultConfig].storeName = v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgForageConfig.prototype, "version", {
        get: function () {
            return this[$defaultConfig].version;
        },
        set: function (v) {
            this[$defaultConfig].version = v;
        },
        enumerable: true,
        configurable: true
    });
    NgForageConfig.prototype.configure = function (opts) {
        opts = opts || {};
        if ('driver' in opts && opts.driver.slice) {
            opts.driver = opts.driver.slice();
        }
        Object.assign(this[$defaultConfig], opts);
        return this;
    };
    NgForageConfig.prototype.defineDriver = function (spec) {
        return localForage.defineDriver(spec);
    };
    NgForageConfig.prototype.toJSON = function () {
        return this.config;
    };
    NgForageConfig.prototype.toString = function () {
        return JSON.stringify(this.toJSON());
    };
    return NgForageConfig;
}());
NgForageConfig.DRIVER_INDEXEDDB = localForage.INDEXEDDB;
NgForageConfig.DRIVER_LOCALSTORAGE = localForage.LOCALSTORAGE;
NgForageConfig.DRIVER_SESSIONSTORAGE = _driver;
NgForageConfig.DRIVER_WEBSQL = localForage.WEBSQL;
NgForageConfig.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] },
];
NgForageConfig.ctorParameters = function () { return [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DEFAULT_CONFIG,] },] },
]; };
NgForageConfig.ngInjectableDef = defineInjectable({ factory: function NgForageConfig_Factory() { return new NgForageConfig(inject(DEFAULT_CONFIG, 8)); }, token: NgForageConfig, providedIn: "root" });
Object.defineProperty(NgForageConfig.prototype, Symbol.toStringTag, { value: 'NgForageConfig' });
var stores = {};
function getDriverString(driver) {
    if (!driver) {
        return '';
    }
    else if (typeof driver === 'string') {
        return driver;
    }
    else {
        return driver.slice().sort().join(',');
    }
}
function getHash(cfg) {
    return [
        getDriverString(cfg.driver),
        cfg.name,
        cfg.size,
        cfg.storeName,
        cfg.version,
        cfg.description,
        cfg.cacheTime
    ].join('|');
}
var conf$ = Symbol('Config');
var InstanceFactory = /** @class */ (function () {
    function InstanceFactory(conf) {
        this[conf$] = conf;
    }
    InstanceFactory.prototype.getInstance = function (cfg) {
        cfg = Object.assign({}, this[conf$].config, cfg || {});
        var hash = getHash(cfg);
        if (!stores[hash]) {
            stores[hash] = localForage.createInstance(cfg);
        }
        return stores[hash];
    };
    return InstanceFactory;
}());
InstanceFactory.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] },
];
InstanceFactory.ctorParameters = function () { return [
    { type: NgForageConfig, },
]; };
InstanceFactory.ngInjectableDef = defineInjectable({ factory: function InstanceFactory_Factory() { return new InstanceFactory(inject(NgForageConfig)); }, token: InstanceFactory, providedIn: "root" });
Object.defineProperty(InstanceFactory.prototype, Symbol.toStringTag, { value: 'InstanceFactory' });
var store$ = Symbol('Store');
var BaseConfigurableImpl = /** @class */ (function () {
    function BaseConfigurableImpl(config, instanceFactory) {
        this.config = {};
        this.storeNeedsRecalc = true;
        this.baseConfig = config;
        this.fact = instanceFactory;
    }
    Object.defineProperty(BaseConfigurableImpl.prototype, "description", {
        get: function () {
            return 'description' in this.config ? this.config.description : this.baseConfig.description;
        },
        set: function (v) {
            this.config.description = v;
            this.storeNeedsRecalc = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseConfigurableImpl.prototype, "driver", {
        get: function () {
            return 'driver' in this.config ? this.config.driver : this.baseConfig.driver;
        },
        set: function (v) {
            this.config.driver = v;
            this.storeNeedsRecalc = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseConfigurableImpl.prototype, "name", {
        get: function () {
            return 'name' in this.config ? this.config.name : this.baseConfig.name;
        },
        set: function (v) {
            this.config.name = v;
            this.storeNeedsRecalc = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseConfigurableImpl.prototype, "size", {
        get: function () {
            return 'size' in this.config ? this.config.size : this.baseConfig.size;
        },
        set: function (v) {
            this.config.size = v;
            this.storeNeedsRecalc = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseConfigurableImpl.prototype, "storeName", {
        get: function () {
            return 'storeName' in this.config ? this.config.storeName : this.baseConfig.storeName;
        },
        set: function (v) {
            this.config.storeName = v;
            this.storeNeedsRecalc = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseConfigurableImpl.prototype, "version", {
        get: function () {
            return 'version' in this.config ? this.config.version : this.baseConfig.version;
        },
        set: function (v) {
            this.config.version = v;
            this.storeNeedsRecalc = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseConfigurableImpl.prototype, "finalConfig", {
        get: function () {
            return Object.assign({}, this.baseConfig.config, this.config);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseConfigurableImpl.prototype, "store", {
        get: function () {
            if (this.storeNeedsRecalc || !this[store$]) {
                this[store$] = this.fact.getInstance(this.finalConfig);
                this.storeNeedsRecalc = false;
            }
            return this[store$];
        },
        enumerable: true,
        configurable: true
    });
    BaseConfigurableImpl.prototype.configure = function (opts) {
        opts = opts || {};
        if ('driver' in opts && opts.driver.slice) {
            opts.driver = opts.driver.slice();
        }
        Object.assign(this.config, opts);
        this.storeNeedsRecalc = true;
        return this;
    };
    BaseConfigurableImpl.prototype.toJSON = function () {
        return {
            description: this.description,
            driver: this.driver,
            name: this.name,
            size: this.size,
            storeName: this.storeName,
            version: this.version
        };
    };
    BaseConfigurableImpl.prototype.toString = function () {
        return JSON.stringify(this.toJSON());
    };
    return BaseConfigurableImpl;
}());
BaseConfigurableImpl.ctorParameters = function () { return [
    { type: NgForageConfig, decorators: [{ type: Inject, args: [NgForageConfig,] },] },
    { type: InstanceFactory, decorators: [{ type: Inject, args: [InstanceFactory,] },] },
]; };
Object.defineProperty(BaseConfigurableImpl.prototype, Symbol.toStringTag, { value: 'BaseConfigurable' });
var NgForage = /** @class */ (function (_super) {
    __extends(NgForage, _super);
    function NgForage() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(NgForage.prototype, "activeDriver", {
        get: function () {
            return this.store.driver();
        },
        enumerable: true,
        configurable: true
    });
    NgForage.prototype.clear = function () {
        return this.store.clear();
    };
    NgForage.prototype.clone = function (config) {
        var inst = new NgForage(this.baseConfig, this.fact);
        inst.configure(Object.assign(this.finalConfig, config || {}));
        return inst;
    };
    NgForage.prototype.getItem = function (key) {
        return this.store.getItem(key);
    };
    NgForage.prototype.iterate = function (iteratee) {
        return this.store.iterate(iteratee);
    };
    NgForage.prototype.key = function (index) {
        return this.store.key(index);
    };
    NgForage.prototype.keys = function () {
        return this.store.keys();
    };
    NgForage.prototype.length = function () {
        return this.store.length();
    };
    NgForage.prototype.ready = function () {
        return this.store.ready();
    };
    NgForage.prototype.removeItem = function (key) {
        return this.store.removeItem(key);
    };
    NgForage.prototype.setItem = function (key, data) {
        return this.store.setItem(key, data);
    };
    NgForage.prototype.supports = function (driver) {
        return this.store.supports(driver);
    };
    return NgForage;
}(BaseConfigurableImpl));
NgForage.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] },
];
NgForage.ngInjectableDef = defineInjectable({ factory: function NgForage_Factory() { return new NgForage(inject(NgForageConfig), inject(InstanceFactory)); }, token: NgForage, providedIn: "root" });
Object.defineProperty(NgForage.prototype, Symbol.toStringTag, { value: 'NgForage' });
var CachedItemImpl = /** @class */ (function () {
    function CachedItemImpl(data, expiryTime) {
        this.data = data;
        this.expires = new Date(typeof expiryTime === 'number' ? expiryTime : 0);
    }
    Object.defineProperty(CachedItemImpl.prototype, "expired", {
        get: function () {
            return this.expiresIn === 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CachedItemImpl.prototype, "expiresIn", {
        get: function () {
            return Math.max(0, this.expires.getTime() - Date.now());
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CachedItemImpl.prototype, "hasData", {
        get: function () {
            return this.data !== null;
        },
        enumerable: true,
        configurable: true
    });
    CachedItemImpl.prototype.toJSON = function () {
        return {
            data: this.data,
            expired: this.expired,
            expires: this.expires,
            expiresIn: this.expiresIn,
            hasData: this.hasData
        };
    };
    CachedItemImpl.prototype.toString = function () {
        return JSON.stringify(this.toJSON());
    };
    return CachedItemImpl;
}());
__decorate([
    LazyGetter(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], CachedItemImpl.prototype, "expired", null);
__decorate([
    LazyGetter(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [])
], CachedItemImpl.prototype, "expiresIn", null);
__decorate([
    LazyGetter(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], CachedItemImpl.prototype, "hasData", null);
Object.defineProperty(CachedItemImpl.prototype, Symbol.toStringTag, { value: 'CachedItem' });
function calculateCacheKeys(mainKey) {
    return {
        data: mainKey + "_data",
        expiry: mainKey + "_expiry"
    };
}
function toCachedItem(r) {
    return new CachedItemImpl(r[0], r[1]);
}
function head(r) {
    return r[0];
}
function toVoid() {
}
var NgForageCache = /** @class */ (function (_super) {
    __extends(NgForageCache, _super);
    function NgForageCache() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(NgForageCache.prototype, "cacheTime", {
        get: function () {
            return 'cacheTime' in this.config ? this.config.cacheTime : this.baseConfig.cacheTime;
        },
        set: function (t) {
            this.config.cacheTime = t;
            this.storeNeedsRecalc = true;
        },
        enumerable: true,
        configurable: true
    });
    NgForageCache.prototype.clone = function (config) {
        var inst = new NgForageCache(this.baseConfig, this.fact);
        inst.configure(Object.assign(this.finalConfig, config || {}));
        return inst;
    };
    NgForageCache.prototype.getCached = function (key) {
        var keys = calculateCacheKeys(key);
        var dataPromise = this.getItem(keys.data);
        var expiryPromise = this.getItem(keys.expiry);
        return Promise.all([dataPromise, expiryPromise]).then(toCachedItem);
    };
    NgForageCache.prototype.removeCached = function (key) {
        var keys = calculateCacheKeys(key);
        var dataPromise = this.removeItem(keys.data);
        var expiryPromise = this.removeItem(keys.expiry);
        return Promise.all([dataPromise, expiryPromise]).then(toVoid);
    };
    NgForageCache.prototype.setCached = function (key, data, cacheTime) {
        var keys = calculateCacheKeys(key);
        var expiry = typeof cacheTime === 'number' ? cacheTime : this.cacheTime;
        var dataPromise = this.setItem(keys.data, data);
        var expiryPromise = this.setItem(keys.expiry, Date.now() + expiry);
        return Promise.all([dataPromise, expiryPromise]).then(head);
    };
    NgForageCache.prototype.toJSON = function () {
        var ass = { cacheTime: this.cacheTime };
        return Object.assign(_super.prototype.toJSON.call(this), ass);
    };
    return NgForageCache;
}(NgForage));
NgForageCache.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] },
];
NgForageCache.ngInjectableDef = defineInjectable({ factory: function NgForageCache_Factory() { return new NgForageCache(inject(NgForageConfig), inject(InstanceFactory)); }, token: NgForageCache, providedIn: "root" });
Object.defineProperty(NgForageCache.prototype, Symbol.toStringTag, { value: 'NgForageCache' });
var NgForageCacheDedicated = /** @class */ (function (_super) {
    __extends(NgForageCacheDedicated, _super);
    function NgForageCacheDedicated() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NgForageCacheDedicated.prototype.clone = function (config) {
        var inst = new NgForageCacheDedicated(this.baseConfig, this.fact);
        inst.configure(Object.assign(this.finalConfig, config || {}));
        return inst;
    };
    return NgForageCacheDedicated;
}(NgForageCache));
Object.defineProperty(NgForageCacheDedicated.prototype, Symbol.toStringTag, { value: 'NgForageCache (dedicated)' });
var NgForageDedicated = /** @class */ (function (_super) {
    __extends(NgForageDedicated, _super);
    function NgForageDedicated() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NgForageDedicated.prototype.clone = function (config) {
        var inst = new NgForageDedicated(this.baseConfig, this.fact);
        inst.configure(Object.assign(this.finalConfig, config || {}));
        return inst;
    };
    return NgForageDedicated;
}(NgForage));
Object.defineProperty(NgForageDedicated.prototype, Symbol.toStringTag, { value: 'NgForage (dedicated)' });
var conf$$1 = Symbol('NgForageConfig');
var if$ = Symbol('InstanceFactory');
var DedicatedInstanceFactory = /** @class */ (function () {
    function DedicatedInstanceFactory(conf, instFact) {
        this[conf$$1] = conf;
        this[if$] = instFact;
    }
    DedicatedInstanceFactory.prototype.createCache = function (config) {
        var inst = new NgForageCacheDedicated((this[conf$$1]), (this[if$]));
        if (config) {
            inst.configure(config);
        }
        return inst;
    };
    DedicatedInstanceFactory.prototype.createNgForage = function (config) {
        var inst = new NgForageDedicated((this[conf$$1]), (this[if$]));
        if (config) {
            inst.configure(config);
        }
        return inst;
    };
    return DedicatedInstanceFactory;
}());
DedicatedInstanceFactory.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] },
];
DedicatedInstanceFactory.ctorParameters = function () { return [
    { type: NgForageConfig, },
    { type: InstanceFactory, },
]; };
DedicatedInstanceFactory.ngInjectableDef = defineInjectable({ factory: function DedicatedInstanceFactory_Factory() { return new DedicatedInstanceFactory(inject(NgForageConfig), inject(InstanceFactory)); }, token: DedicatedInstanceFactory, providedIn: "root" });

export { NgForageModule, NgForage, NgForageCache, NgForageConfig, InstanceFactory, DedicatedInstanceFactory, DEFAULT_CONFIG as ɵa, BaseConfigurableImpl as ɵb };
//# sourceMappingURL=ngforage.js.map
