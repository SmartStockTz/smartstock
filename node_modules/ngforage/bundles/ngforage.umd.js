/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2017 Arturas Molcanovas <a.molcanovas@gmail.com> (https://github.com/Alorel/ngforage)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('localforage'), require('@angular/core'), require('typescript-lazy-get-decorator')) :
	typeof define === 'function' && define.amd ? define('ngforage', ['exports', 'localforage', '@angular/core', 'typescript-lazy-get-decorator'], factory) :
	(factory((global.ngforage = {}),global.localforage,global.ng.core,global.LazyGet));
}(this, (function (exports,localforage,core,typescriptLazyGetDecorator) { 'use strict';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0
THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.
See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */
var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}


function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

var lf = require('localforage');
var localForage = 'defineDriver' in lf ? lf : lf.default;
var serializer$ = require('localforage/src/utils/serializer');
var serializer = serializer$.default || serializer$;
function _getKeyPrefix(options, defaultConfig) {
    var keyPrefix = options.name + "/";
    if (options.storeName !== defaultConfig.storeName) {
        keyPrefix += options.storeName + "/";
    }
    return keyPrefix;
}
function checkIfSessionStorageThrows() {
    var testKey = '_localforage_support_test';
    try {
        sessionStorage.setItem(testKey, '1');
        sessionStorage.removeItem(testKey);
        return false;
    }
    catch (e) {
        return true;
    }
}
function _isSessionStorageUsable() {
    return typeof sessionStorage !== 'undefined' && (!checkIfSessionStorageThrows() || sessionStorage.length > 0);
}
function _initStorage(options) {
    var dbInfo = {};
    if (options) {
        for (var i in options) {
            dbInfo[i] = options[i];
        }
    }
    dbInfo.keyPrefix = _getKeyPrefix(options, this._defaultConfig);
    if (!_isSessionStorageUsable()) {
        return Promise.reject(new Error('Local storage unusable'));
    }
    this._dbInfo = dbInfo;
    dbInfo.serializer = serializer;
    return Promise.resolve();
}
function executeCallback(promise, callback) {
    if (callback) {
        promise.then(function (result) {
            callback(null, result);
        }, function (error) {
            callback(error);
        });
    }
}
function clear(callback) {
    var _this = this;
    var promise = this.ready().then(function () {
        var keyPrefix = _this._dbInfo.keyPrefix;
        for (var i = sessionStorage.length - 1; i >= 0; i--) {
            var key$ = sessionStorage.key(i);
            if (key$ !== null && key$.indexOf(keyPrefix) === 0) {
                sessionStorage.removeItem(key$);
            }
        }
    });
    executeCallback(promise, callback);
    return promise;
}
function getCallback() {
    if (arguments.length && typeof arguments[arguments.length - 1] === 'function') {
        return arguments[arguments.length - 1];
    }
}
function dropInstance(options, callback) {
    var _this = this;
    callback = getCallback.apply(this, arguments);
    options = (typeof options !== 'function' && options) || {};
    if (!options.name) {
        var currentConfig = this.config();
        options.name = options.name || currentConfig.name;
        options.storeName = options.storeName || currentConfig.storeName;
    }
    var promise;
    if (!options.name) {
        promise = Promise.reject('Invalid arguments');
    }
    else {
        promise = new Promise(function (resolve) {
            if (!options.storeName) {
                resolve(options.name + "/");
            }
            else {
                resolve(_getKeyPrefix(options, _this._defaultConfig));
            }
        })
            .then(function (keyPrefix) {
            for (var i = sessionStorage.length - 1; i >= 0; i--) {
                var key$ = sessionStorage.key(i);
                if (key$ !== null && key$.indexOf(keyPrefix) === 0) {
                    sessionStorage.removeItem(key$);
                }
            }
        });
    }
    executeCallback(promise, callback);
    return promise;
}
function normalizeKey(key) {
    if (typeof key !== 'string') {
        console.warn(key + " used as a key, but it is not a string.");
        key = String(key);
    }
    return key;
}
function getItem(key$, callback) {
    var _this = this;
    key$ = normalizeKey(key$);
    var promise = this.ready().then(function () {
        var result = sessionStorage.getItem("" + _this._dbInfo.keyPrefix + key$);
        if (result) {
            result = _this._dbInfo.serializer.deserialize(result);
        }
        return result;
    });
    executeCallback(promise, callback);
    return promise;
}
function iterate(iterator, callback) {
    var _this = this;
    var promise = this.ready().then(function () {
        var keyPrefix = _this._dbInfo.keyPrefix;
        var keyPrefixLength = keyPrefix.length;
        var length$ = sessionStorage.length;
        var iterationNumber = 1;
        for (var i = 0; i < length$; i++) {
            var key$ = sessionStorage.key(i);
            if (key$ === null || key$.indexOf(keyPrefix) !== 0) {
                continue;
            }
            var value = sessionStorage.getItem(key$);
            if (value) {
                value = _this._dbInfo.serializer.deserialize(value);
            }
            value = iterator(value, key$.substring(keyPrefixLength), iterationNumber++);
            if (value !== void 0) {
                return value;
            }
        }
    });
    executeCallback(promise, callback);
    return promise;
}
function key(n, callback) {
    var _this = this;
    var promise = this.ready().then(function () {
        var result;
        try {
            result = sessionStorage.key(n);
        }
        catch (error) {
            result = null;
        }
        if (result) {
            result = result.substring(_this._dbInfo.keyPrefix.length);
        }
        return result;
    });
    executeCallback(promise, callback);
    return promise;
}
function keys(callback) {
    var _this = this;
    var promise = this.ready().then(function () {
        var length$ = sessionStorage.length;
        var keys$ = [];
        for (var i = 0; i < length$; i++) {
            var itemKey = sessionStorage.key(i);
            if (itemKey !== null && itemKey.indexOf(_this._dbInfo.keyPrefix) === 0) {
                keys$.push(itemKey.substring(_this._dbInfo.keyPrefix.length));
            }
        }
        return keys$;
    });
    executeCallback(promise, callback);
    return promise;
}
function length(callback) {
    var promise = this.keys().then(function (keys$) { return keys$.length; });
    executeCallback(promise, callback);
    return promise;
}
function removeItem(key$, callback) {
    var _this = this;
    key$ = normalizeKey(key$);
    var promise = this.ready().then(function () {
        sessionStorage.removeItem("" + _this._dbInfo.keyPrefix + key$);
    });
    executeCallback(promise, callback);
    return promise;
}
function setItem(key$, value, callback) {
    var _this = this;
    key$ = normalizeKey(key$);
    var promise = this.ready().then(function () {
        if (value === undefined) {
            value = null;
        }
        var originalValue = value;
        return new Promise(function (resolve, reject) {
            _this._dbInfo.serializer.serialize(value, function (value$, error) {
                if (error) {
                    reject(error);
                }
                else {
                    try {
                        sessionStorage.setItem("" + _this._dbInfo.keyPrefix + key$, value$);
                        resolve(originalValue);
                    }
                    catch (e) {
                        if (e.name === 'QuotaExceededError' ||
                            e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {
                            reject(e);
                        }
                        reject(e);
                    }
                }
            });
        });
    });
    executeCallback(promise, callback);
    return promise;
}
var _driver = 'ngforage_sessionStorage';
var sessionStorageWrapper = {
    _driver: _driver,
    _initStorage: _initStorage,
    _support: _isSessionStorageUsable(),
    clear: clear,
    dropInstance: dropInstance,
    getItem: getItem,
    iterate: iterate,
    key: key,
    keys: keys,
    length: length,
    removeItem: removeItem,
    setItem: setItem
};
localForage.defineDriver(sessionStorageWrapper).catch(console.error);
var DEFAULT_CONFIG = new core.InjectionToken('Default NgForage config');
var NgForageModule = /** @class */ (function () {
    function NgForageModule() {
    }
    NgForageModule.forRoot = function (config) {
        if (config === void 0) { config = {}; }
        return {
            ngModule: NgForageModule,
            providers: [
                {
                    provide: DEFAULT_CONFIG,
                    useValue: Object.assign({}, config)
                }
            ]
        };
    };
    return NgForageModule;
}());
NgForageModule.decorators = [
    { type: core.NgModule, args: [{},] },
];
var $defaultConfig = Symbol('Default Config');
var NgForageConfig = /** @class */ (function () {
    function NgForageConfig(conf) {
        this[$defaultConfig] = {
            cacheTime: 300000,
            description: '',
            driver: [localForage.INDEXEDDB, localForage.WEBSQL, localForage.LOCALSTORAGE],
            name: 'ngForage',
            size: 4980736,
            storeName: 'ng_forage',
            version: 1
        };
        if (conf) {
            this.configure(conf);
        }
    }
    Object.defineProperty(NgForageConfig.prototype, "cacheTime", {
        get: function () {
            return this[$defaultConfig].cacheTime;
        },
        set: function (t) {
            this[$defaultConfig].cacheTime = t;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgForageConfig.prototype, "config", {
        get: function () {
            return {
                cacheTime: this.cacheTime,
                description: this.description,
                driver: this.driver,
                name: this.name,
                size: this.size,
                storeName: this.storeName,
                version: this.version
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgForageConfig.prototype, "description", {
        get: function () {
            return this[$defaultConfig].description;
        },
        set: function (v) {
            this[$defaultConfig].description = v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgForageConfig.prototype, "driver", {
        get: function () {
            if (typeof this[$defaultConfig].driver === 'string') {
                return this[$defaultConfig].driver;
            }
            return this[$defaultConfig].driver.slice();
        },
        set: function (v) {
            this[$defaultConfig].driver = v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgForageConfig.prototype, "name", {
        get: function () {
            return this[$defaultConfig].name;
        },
        set: function (v) {
            this[$defaultConfig].name = v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgForageConfig.prototype, "size", {
        get: function () {
            return this[$defaultConfig].size;
        },
        set: function (v) {
            this[$defaultConfig].size = v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgForageConfig.prototype, "storeName", {
        get: function () {
            return this[$defaultConfig].storeName;
        },
        set: function (v) {
            this[$defaultConfig].storeName = v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgForageConfig.prototype, "version", {
        get: function () {
            return this[$defaultConfig].version;
        },
        set: function (v) {
            this[$defaultConfig].version = v;
        },
        enumerable: true,
        configurable: true
    });
    NgForageConfig.prototype.configure = function (opts) {
        opts = opts || {};
        if ('driver' in opts && opts.driver.slice) {
            opts.driver = opts.driver.slice();
        }
        Object.assign(this[$defaultConfig], opts);
        return this;
    };
    NgForageConfig.prototype.defineDriver = function (spec) {
        return localForage.defineDriver(spec);
    };
    NgForageConfig.prototype.toJSON = function () {
        return this.config;
    };
    NgForageConfig.prototype.toString = function () {
        return JSON.stringify(this.toJSON());
    };
    return NgForageConfig;
}());
NgForageConfig.DRIVER_INDEXEDDB = localForage.INDEXEDDB;
NgForageConfig.DRIVER_LOCALSTORAGE = localForage.LOCALSTORAGE;
NgForageConfig.DRIVER_SESSIONSTORAGE = _driver;
NgForageConfig.DRIVER_WEBSQL = localForage.WEBSQL;
NgForageConfig.decorators = [
    { type: core.Injectable, args: [{ providedIn: 'root' },] },
];
NgForageConfig.ctorParameters = function () { return [
    { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [DEFAULT_CONFIG,] },] },
]; };
NgForageConfig.ngInjectableDef = core.defineInjectable({ factory: function NgForageConfig_Factory() { return new NgForageConfig(core.inject(DEFAULT_CONFIG, 8)); }, token: NgForageConfig, providedIn: "root" });
Object.defineProperty(NgForageConfig.prototype, Symbol.toStringTag, { value: 'NgForageConfig' });
var stores = {};
function getDriverString(driver) {
    if (!driver) {
        return '';
    }
    else if (typeof driver === 'string') {
        return driver;
    }
    else {
        return driver.slice().sort().join(',');
    }
}
function getHash(cfg) {
    return [
        getDriverString(cfg.driver),
        cfg.name,
        cfg.size,
        cfg.storeName,
        cfg.version,
        cfg.description,
        cfg.cacheTime
    ].join('|');
}
var conf$ = Symbol('Config');
var InstanceFactory = /** @class */ (function () {
    function InstanceFactory(conf) {
        this[conf$] = conf;
    }
    InstanceFactory.prototype.getInstance = function (cfg) {
        cfg = Object.assign({}, this[conf$].config, cfg || {});
        var hash = getHash(cfg);
        if (!stores[hash]) {
            stores[hash] = localForage.createInstance(cfg);
        }
        return stores[hash];
    };
    return InstanceFactory;
}());
InstanceFactory.decorators = [
    { type: core.Injectable, args: [{ providedIn: 'root' },] },
];
InstanceFactory.ctorParameters = function () { return [
    { type: NgForageConfig, },
]; };
InstanceFactory.ngInjectableDef = core.defineInjectable({ factory: function InstanceFactory_Factory() { return new InstanceFactory(core.inject(NgForageConfig)); }, token: InstanceFactory, providedIn: "root" });
Object.defineProperty(InstanceFactory.prototype, Symbol.toStringTag, { value: 'InstanceFactory' });
var store$ = Symbol('Store');
var BaseConfigurableImpl = /** @class */ (function () {
    function BaseConfigurableImpl(config, instanceFactory) {
        this.config = {};
        this.storeNeedsRecalc = true;
        this.baseConfig = config;
        this.fact = instanceFactory;
    }
    Object.defineProperty(BaseConfigurableImpl.prototype, "description", {
        get: function () {
            return 'description' in this.config ? this.config.description : this.baseConfig.description;
        },
        set: function (v) {
            this.config.description = v;
            this.storeNeedsRecalc = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseConfigurableImpl.prototype, "driver", {
        get: function () {
            return 'driver' in this.config ? this.config.driver : this.baseConfig.driver;
        },
        set: function (v) {
            this.config.driver = v;
            this.storeNeedsRecalc = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseConfigurableImpl.prototype, "name", {
        get: function () {
            return 'name' in this.config ? this.config.name : this.baseConfig.name;
        },
        set: function (v) {
            this.config.name = v;
            this.storeNeedsRecalc = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseConfigurableImpl.prototype, "size", {
        get: function () {
            return 'size' in this.config ? this.config.size : this.baseConfig.size;
        },
        set: function (v) {
            this.config.size = v;
            this.storeNeedsRecalc = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseConfigurableImpl.prototype, "storeName", {
        get: function () {
            return 'storeName' in this.config ? this.config.storeName : this.baseConfig.storeName;
        },
        set: function (v) {
            this.config.storeName = v;
            this.storeNeedsRecalc = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseConfigurableImpl.prototype, "version", {
        get: function () {
            return 'version' in this.config ? this.config.version : this.baseConfig.version;
        },
        set: function (v) {
            this.config.version = v;
            this.storeNeedsRecalc = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseConfigurableImpl.prototype, "finalConfig", {
        get: function () {
            return Object.assign({}, this.baseConfig.config, this.config);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseConfigurableImpl.prototype, "store", {
        get: function () {
            if (this.storeNeedsRecalc || !this[store$]) {
                this[store$] = this.fact.getInstance(this.finalConfig);
                this.storeNeedsRecalc = false;
            }
            return this[store$];
        },
        enumerable: true,
        configurable: true
    });
    BaseConfigurableImpl.prototype.configure = function (opts) {
        opts = opts || {};
        if ('driver' in opts && opts.driver.slice) {
            opts.driver = opts.driver.slice();
        }
        Object.assign(this.config, opts);
        this.storeNeedsRecalc = true;
        return this;
    };
    BaseConfigurableImpl.prototype.toJSON = function () {
        return {
            description: this.description,
            driver: this.driver,
            name: this.name,
            size: this.size,
            storeName: this.storeName,
            version: this.version
        };
    };
    BaseConfigurableImpl.prototype.toString = function () {
        return JSON.stringify(this.toJSON());
    };
    return BaseConfigurableImpl;
}());
BaseConfigurableImpl.ctorParameters = function () { return [
    { type: NgForageConfig, decorators: [{ type: core.Inject, args: [NgForageConfig,] },] },
    { type: InstanceFactory, decorators: [{ type: core.Inject, args: [InstanceFactory,] },] },
]; };
Object.defineProperty(BaseConfigurableImpl.prototype, Symbol.toStringTag, { value: 'BaseConfigurable' });
var NgForage = /** @class */ (function (_super) {
    __extends(NgForage, _super);
    function NgForage() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(NgForage.prototype, "activeDriver", {
        get: function () {
            return this.store.driver();
        },
        enumerable: true,
        configurable: true
    });
    NgForage.prototype.clear = function () {
        return this.store.clear();
    };
    NgForage.prototype.clone = function (config) {
        var inst = new NgForage(this.baseConfig, this.fact);
        inst.configure(Object.assign(this.finalConfig, config || {}));
        return inst;
    };
    NgForage.prototype.getItem = function (key) {
        return this.store.getItem(key);
    };
    NgForage.prototype.iterate = function (iteratee) {
        return this.store.iterate(iteratee);
    };
    NgForage.prototype.key = function (index) {
        return this.store.key(index);
    };
    NgForage.prototype.keys = function () {
        return this.store.keys();
    };
    NgForage.prototype.length = function () {
        return this.store.length();
    };
    NgForage.prototype.ready = function () {
        return this.store.ready();
    };
    NgForage.prototype.removeItem = function (key) {
        return this.store.removeItem(key);
    };
    NgForage.prototype.setItem = function (key, data) {
        return this.store.setItem(key, data);
    };
    NgForage.prototype.supports = function (driver) {
        return this.store.supports(driver);
    };
    return NgForage;
}(BaseConfigurableImpl));
NgForage.decorators = [
    { type: core.Injectable, args: [{ providedIn: 'root' },] },
];
NgForage.ngInjectableDef = core.defineInjectable({ factory: function NgForage_Factory() { return new NgForage(core.inject(NgForageConfig), core.inject(InstanceFactory)); }, token: NgForage, providedIn: "root" });
Object.defineProperty(NgForage.prototype, Symbol.toStringTag, { value: 'NgForage' });
var CachedItemImpl = /** @class */ (function () {
    function CachedItemImpl(data, expiryTime) {
        this.data = data;
        this.expires = new Date(typeof expiryTime === 'number' ? expiryTime : 0);
    }
    Object.defineProperty(CachedItemImpl.prototype, "expired", {
        get: function () {
            return this.expiresIn === 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CachedItemImpl.prototype, "expiresIn", {
        get: function () {
            return Math.max(0, this.expires.getTime() - Date.now());
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CachedItemImpl.prototype, "hasData", {
        get: function () {
            return this.data !== null;
        },
        enumerable: true,
        configurable: true
    });
    CachedItemImpl.prototype.toJSON = function () {
        return {
            data: this.data,
            expired: this.expired,
            expires: this.expires,
            expiresIn: this.expiresIn,
            hasData: this.hasData
        };
    };
    CachedItemImpl.prototype.toString = function () {
        return JSON.stringify(this.toJSON());
    };
    return CachedItemImpl;
}());
__decorate([
    typescriptLazyGetDecorator.LazyGetter(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], CachedItemImpl.prototype, "expired", null);
__decorate([
    typescriptLazyGetDecorator.LazyGetter(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [])
], CachedItemImpl.prototype, "expiresIn", null);
__decorate([
    typescriptLazyGetDecorator.LazyGetter(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], CachedItemImpl.prototype, "hasData", null);
Object.defineProperty(CachedItemImpl.prototype, Symbol.toStringTag, { value: 'CachedItem' });
function calculateCacheKeys(mainKey) {
    return {
        data: mainKey + "_data",
        expiry: mainKey + "_expiry"
    };
}
function toCachedItem(r) {
    return new CachedItemImpl(r[0], r[1]);
}
function head(r) {
    return r[0];
}
function toVoid() {
}
var NgForageCache = /** @class */ (function (_super) {
    __extends(NgForageCache, _super);
    function NgForageCache() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(NgForageCache.prototype, "cacheTime", {
        get: function () {
            return 'cacheTime' in this.config ? this.config.cacheTime : this.baseConfig.cacheTime;
        },
        set: function (t) {
            this.config.cacheTime = t;
            this.storeNeedsRecalc = true;
        },
        enumerable: true,
        configurable: true
    });
    NgForageCache.prototype.clone = function (config) {
        var inst = new NgForageCache(this.baseConfig, this.fact);
        inst.configure(Object.assign(this.finalConfig, config || {}));
        return inst;
    };
    NgForageCache.prototype.getCached = function (key) {
        var keys = calculateCacheKeys(key);
        var dataPromise = this.getItem(keys.data);
        var expiryPromise = this.getItem(keys.expiry);
        return Promise.all([dataPromise, expiryPromise]).then(toCachedItem);
    };
    NgForageCache.prototype.removeCached = function (key) {
        var keys = calculateCacheKeys(key);
        var dataPromise = this.removeItem(keys.data);
        var expiryPromise = this.removeItem(keys.expiry);
        return Promise.all([dataPromise, expiryPromise]).then(toVoid);
    };
    NgForageCache.prototype.setCached = function (key, data, cacheTime) {
        var keys = calculateCacheKeys(key);
        var expiry = typeof cacheTime === 'number' ? cacheTime : this.cacheTime;
        var dataPromise = this.setItem(keys.data, data);
        var expiryPromise = this.setItem(keys.expiry, Date.now() + expiry);
        return Promise.all([dataPromise, expiryPromise]).then(head);
    };
    NgForageCache.prototype.toJSON = function () {
        var ass = { cacheTime: this.cacheTime };
        return Object.assign(_super.prototype.toJSON.call(this), ass);
    };
    return NgForageCache;
}(NgForage));
NgForageCache.decorators = [
    { type: core.Injectable, args: [{ providedIn: 'root' },] },
];
NgForageCache.ngInjectableDef = core.defineInjectable({ factory: function NgForageCache_Factory() { return new NgForageCache(core.inject(NgForageConfig), core.inject(InstanceFactory)); }, token: NgForageCache, providedIn: "root" });
Object.defineProperty(NgForageCache.prototype, Symbol.toStringTag, { value: 'NgForageCache' });
var NgForageCacheDedicated = /** @class */ (function (_super) {
    __extends(NgForageCacheDedicated, _super);
    function NgForageCacheDedicated() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NgForageCacheDedicated.prototype.clone = function (config) {
        var inst = new NgForageCacheDedicated(this.baseConfig, this.fact);
        inst.configure(Object.assign(this.finalConfig, config || {}));
        return inst;
    };
    return NgForageCacheDedicated;
}(NgForageCache));
Object.defineProperty(NgForageCacheDedicated.prototype, Symbol.toStringTag, { value: 'NgForageCache (dedicated)' });
var NgForageDedicated = /** @class */ (function (_super) {
    __extends(NgForageDedicated, _super);
    function NgForageDedicated() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NgForageDedicated.prototype.clone = function (config) {
        var inst = new NgForageDedicated(this.baseConfig, this.fact);
        inst.configure(Object.assign(this.finalConfig, config || {}));
        return inst;
    };
    return NgForageDedicated;
}(NgForage));
Object.defineProperty(NgForageDedicated.prototype, Symbol.toStringTag, { value: 'NgForage (dedicated)' });
var conf$$1 = Symbol('NgForageConfig');
var if$ = Symbol('InstanceFactory');
var DedicatedInstanceFactory = /** @class */ (function () {
    function DedicatedInstanceFactory(conf, instFact) {
        this[conf$$1] = conf;
        this[if$] = instFact;
    }
    DedicatedInstanceFactory.prototype.createCache = function (config) {
        var inst = new NgForageCacheDedicated((this[conf$$1]), (this[if$]));
        if (config) {
            inst.configure(config);
        }
        return inst;
    };
    DedicatedInstanceFactory.prototype.createNgForage = function (config) {
        var inst = new NgForageDedicated((this[conf$$1]), (this[if$]));
        if (config) {
            inst.configure(config);
        }
        return inst;
    };
    return DedicatedInstanceFactory;
}());
DedicatedInstanceFactory.decorators = [
    { type: core.Injectable, args: [{ providedIn: 'root' },] },
];
DedicatedInstanceFactory.ctorParameters = function () { return [
    { type: NgForageConfig, },
    { type: InstanceFactory, },
]; };
DedicatedInstanceFactory.ngInjectableDef = core.defineInjectable({ factory: function DedicatedInstanceFactory_Factory() { return new DedicatedInstanceFactory(core.inject(NgForageConfig), core.inject(InstanceFactory)); }, token: DedicatedInstanceFactory, providedIn: "root" });

exports.NgForageModule = NgForageModule;
exports.NgForage = NgForage;
exports.NgForageCache = NgForageCache;
exports.NgForageConfig = NgForageConfig;
exports.InstanceFactory = InstanceFactory;
exports.DedicatedInstanceFactory = DedicatedInstanceFactory;
exports.ɵa = DEFAULT_CONFIG;
exports.ɵb = BaseConfigurableImpl;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngforage.umd.js.map
