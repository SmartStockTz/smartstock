/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2017 Arturas Molcanovas <a.molcanovas@gmail.com> (https://github.com/Alorel/ngforage)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

import 'localforage';
import { InjectionToken, NgModule, Inject, Injectable, Optional, defineInjectable, inject } from '@angular/core';
import { __decorate, __metadata } from 'tslib';
import { LazyGetter } from 'typescript-lazy-get-decorator';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@internal
 */
const lf = require('localforage');
/**
 * \@internal
 */
const localForage = 'defineDriver' in lf ? lf : lf.default;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@internal
 */
const serializer$ = require('localforage/src/utils/serializer');
/**
 * \@internal
 */
const serializer = serializer$.default || serializer$;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@internal
 * @param {?} options
 * @param {?} defaultConfig
 * @return {?}
 */
function _getKeyPrefix(options, defaultConfig) {
    let /** @type {?} */ keyPrefix = `${options.name}/`;
    if (options.storeName !== defaultConfig.storeName) {
        keyPrefix += `${options.storeName}/`;
    }
    return keyPrefix;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Check if sessionStorage throws when saving an item
 * \@internal
 * @return {?}
 */
function checkIfSessionStorageThrows() {
    const /** @type {?} */ testKey = '_localforage_support_test';
    try {
        sessionStorage.setItem(testKey, '1');
        sessionStorage.removeItem(testKey);
        return false;
    }
    catch (/** @type {?} */ e) {
        return true;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@internal
 * @return {?}
 */
function _isSessionStorageUsable() {
    return typeof sessionStorage !== 'undefined' && (!checkIfSessionStorageThrows() || sessionStorage.length > 0);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@internal
 * @this {?}
 * @param {?} options
 * @return {?}
 */
function _initStorage(options) {
    const /** @type {?} */ dbInfo = {};
    if (options) {
        for (let /** @type {?} */ i in options) {
            //tslint:disable-line:forin
            dbInfo[i] = options[i];
        }
    }
    dbInfo.keyPrefix = _getKeyPrefix(options, this._defaultConfig);
    if (!_isSessionStorageUsable()) {
        return Promise.reject(new Error('Local storage unusable'));
    }
    this._dbInfo = dbInfo;
    dbInfo.serializer = serializer;
    return Promise.resolve();
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@internal
 * @param {?} promise
 * @param {?=} callback
 * @return {?}
 */
function executeCallback(promise, callback) {
    if (callback) {
        promise.then((result) => {
            callback(null, result);
        }, (error) => {
            callback(error);
        });
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@internal
 * @this {?}
 * @param {?=} callback
 * @return {?}
 */
function clear(callback) {
    const /** @type {?} */ promise = this.ready().then(() => {
        const /** @type {?} */ keyPrefix = this._dbInfo.keyPrefix;
        for (let /** @type {?} */ i = sessionStorage.length - 1; i >= 0; i--) {
            let /** @type {?} */ key$ = sessionStorage.key(i);
            if (key$ !== null && key$.indexOf(keyPrefix) === 0) {
                sessionStorage.removeItem(key$);
            }
        }
    });
    executeCallback(promise, callback);
    return promise;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@internal
 * @return {?}
 */
function getCallback() {
    if (arguments.length && typeof arguments[arguments.length - 1] === 'function') {
        return arguments[arguments.length - 1];
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@internal
 * @this {?}
 * @param {?} options
 * @param {?=} callback
 * @return {?}
 */
function dropInstance(options, callback) {
    callback = getCallback.apply(this, arguments);
    options = (typeof options !== 'function' && options) || {};
    if (!options.name) {
        const /** @type {?} */ currentConfig = this.config();
        options.name = options.name || currentConfig.name;
        options.storeName = options.storeName || currentConfig.storeName;
    }
    let /** @type {?} */ promise;
    if (!options.name) {
        promise = Promise.reject('Invalid arguments');
    }
    else {
        promise = new Promise(resolve => {
            if (!options.storeName) {
                resolve(`${options.name}/`);
            }
            else {
                resolve(_getKeyPrefix(options, this._defaultConfig));
            }
        })
            .then((keyPrefix) => {
            for (let /** @type {?} */ i = sessionStorage.length - 1; i >= 0; i--) {
                const /** @type {?} */ key$ = sessionStorage.key(i);
                if (key$ !== null && key$.indexOf(keyPrefix) === 0) {
                    sessionStorage.removeItem(key$);
                }
            }
        });
    }
    executeCallback(promise, callback);
    return promise;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@internal
 * @param {?} key
 * @return {?}
 */
function normalizeKey(key) {
    // Cast the key to a string, as that's all we can set as a key.
    if (typeof key !== 'string') {
        console.warn(`${key} used as a key, but it is not a string.`);
        key = String(key);
    }
    return key;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@internal
 * @this {?}
 * @param {?} key$
 * @param {?=} callback
 * @return {?}
 */
function getItem(key$, callback) {
    key$ = normalizeKey(key$);
    const /** @type {?} */ promise = this.ready().then(() => {
        let /** @type {?} */ result = sessionStorage.getItem(`${this._dbInfo.keyPrefix}${key$}`);
        // If a result was found, parse it from the serialized
        // string into a JS object. If result isn't truthy, the key
        // is likely undefined and we'll pass it straight to the
        // callback.
        if (result) {
            result = this._dbInfo.serializer.deserialize(result);
        }
        return result;
    });
    executeCallback(promise, callback);
    return promise;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@internal
 * @this {?}
 * @param {?} iterator
 * @param {?=} callback
 * @return {?}
 */
function iterate(iterator, callback) {
    const /** @type {?} */ promise = this.ready().then(() => {
        const /** @type {?} */ keyPrefix = this._dbInfo.keyPrefix;
        const /** @type {?} */ keyPrefixLength = keyPrefix.length;
        const /** @type {?} */ length$ = sessionStorage.length;
        // We use a dedicated iterator instead of the `i` variable below
        // so other keys we fetch in sessionStorage aren't counted in
        // the `iterationNumber` argument passed to the `iterate()`
        // callback.
        //
        // See: github.com/mozilla/localForage/pull/435#discussion_r38061530
        let /** @type {?} */ iterationNumber = 1;
        for (let /** @type {?} */ i = 0; i < length$; i++) {
            const /** @type {?} */ key$ = sessionStorage.key(i);
            if (key$ === null || key$.indexOf(keyPrefix) !== 0) {
                continue;
            }
            let /** @type {?} */ value = sessionStorage.getItem(key$);
            // If a result was found, parse it from the serialized
            // string into a JS object. If result isn't truthy, the
            // key is likely undefined and we'll pass it straight
            // to the iterator.
            if (value) {
                value = this._dbInfo.serializer.deserialize(value);
            }
            value = iterator(value, key$.substring(keyPrefixLength), iterationNumber++);
            if (value !== void 0) {
                return value;
            }
        }
    });
    executeCallback(promise, callback);
    return promise;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@internal
 * @this {?}
 * @param {?} n
 * @param {?=} callback
 * @return {?}
 */
function key(n, callback) {
    const /** @type {?} */ promise = this.ready().then(() => {
        let /** @type {?} */ result;
        try {
            result = sessionStorage.key(n);
        }
        catch (/** @type {?} */ error) {
            result = null;
        }
        // Remove the prefix from the key, if a key is found.
        if (result) {
            result = result.substring(this._dbInfo.keyPrefix.length);
        }
        return result;
    });
    executeCallback(promise, callback);
    return promise;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@internal
 * @this {?}
 * @param {?=} callback
 * @return {?}
 */
function keys(callback) {
    const /** @type {?} */ promise = this.ready().then(() => {
        const /** @type {?} */ length$ = sessionStorage.length;
        const /** @type {?} */ keys$ = [];
        for (let /** @type {?} */ i = 0; i < length$; i++) {
            const /** @type {?} */ itemKey = sessionStorage.key(i);
            if (itemKey !== null && itemKey.indexOf(this._dbInfo.keyPrefix) === 0) {
                keys$.push(itemKey.substring(this._dbInfo.keyPrefix.length));
            }
        }
        return keys$;
    });
    executeCallback(promise, callback);
    return promise;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@internal
 * @this {?}
 * @param {?=} callback
 * @return {?}
 */
function length(callback) {
    const /** @type {?} */ promise = this.keys().then((keys$) => keys$.length);
    executeCallback(promise, callback);
    return promise;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@internal
 * @this {?}
 * @param {?} key$
 * @param {?=} callback
 * @return {?}
 */
function removeItem(key$, callback) {
    key$ = normalizeKey(key$);
    const /** @type {?} */ promise = this.ready().then(() => {
        sessionStorage.removeItem(`${this._dbInfo.keyPrefix}${key$}`);
    });
    executeCallback(promise, callback);
    return promise;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@internal
 * @this {?}
 * @param {?} key$
 * @param {?} value
 * @param {?=} callback
 * @return {?}
 */
function setItem(key$, value, callback) {
    key$ = normalizeKey(key$);
    const /** @type {?} */ promise = this.ready().then(() => {
        // Convert undefined values to null.
        // https://github.com/mozilla/localForage/pull/42
        if (value === undefined) {
            value = null;
        }
        // Save the original value to pass to the callback.
        const /** @type {?} */ originalValue = value;
        return new Promise((resolve, reject) => {
            this._dbInfo.serializer.serialize(value, (value$, error) => {
                if (error) {
                    reject(error);
                }
                else {
                    try {
                        sessionStorage.setItem(`${this._dbInfo.keyPrefix}${key$}`, value$);
                        resolve(originalValue);
                    }
                    catch (/** @type {?} */ e) {
                        // sessionStorage capacity exceeded.
                        if (e.name === 'QuotaExceededError' ||
                            e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {
                            reject(e);
                        }
                        reject(e);
                    }
                }
            });
        });
    });
    executeCallback(promise, callback);
    return promise;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@internal
 */
const _driver = 'ngforage_sessionStorage';
/**
 * \@internal
 */
const sessionStorageWrapper = {
    _driver,
    _initStorage,
    _support: _isSessionStorageUsable(),
    clear,
    dropInstance,
    getItem,
    iterate,
    key,
    keys,
    length,
    removeItem,
    setItem
};
//tslint:disable-next-line:no-unbound-method
localForage.defineDriver(sessionStorageWrapper).catch(console.error);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const DEFAULT_CONFIG = new InjectionToken('Default NgForage config');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * NgForage core module
 */
class NgForageModule {
    /**
     * @param {?=} config
     * @return {?}
     */
    static forRoot(config = {}) {
        return {
            ngModule: NgForageModule,
            providers: [
                {
                    provide: DEFAULT_CONFIG,
                    useValue: Object.assign({}, config)
                }
            ]
        };
    }
}
NgForageModule.decorators = [
    { type: NgModule, args: [{},] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const $defaultConfig = Symbol('Default Config');
/**
 * Global/default configuration
 */
class NgForageConfig {
    /**
     * @param {?} conf
     */
    constructor(conf) {
        this[$defaultConfig] = {
            cacheTime: 300000,
            description: '',
            driver: [localForage.INDEXEDDB, localForage.WEBSQL, localForage.LOCALSTORAGE],
            name: 'ngForage',
            size: 4980736,
            storeName: 'ng_forage',
            version: 1
        };
        if (conf) {
            this.configure(conf);
        }
    }
    /**
     * Cache time in milliseconds
     * \@default 300000
     * @return {?}
     */
    get cacheTime() {
        return this[$defaultConfig].cacheTime;
    }
    /**
     * @param {?} t
     * @return {?}
     */
    set cacheTime(t) {
        this[$defaultConfig].cacheTime = t;
    }
    /**
     * Get the compiled configuration
     * @return {?}
     */
    get config() {
        return {
            cacheTime: this.cacheTime,
            description: this.description,
            driver: this.driver,
            name: this.name,
            size: this.size,
            storeName: this.storeName,
            version: this.version
        };
    }
    /**
     * A description of the database, essentially for developer usage.
     * \@default
     * @return {?}
     */
    get description() {
        return this[$defaultConfig].description;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set description(v) {
        this[$defaultConfig].description = v;
    }
    /**
     * The preferred driver(s) to use.
     * @see {\@link NgForageConfig#DRIVER_INDEXEDDB}
     * @see {\@link NgForageConfig#DRIVER_WEBSQL}
     * @see {\@link NgForageConfig#DRIVER_LOCALSTORAGE}
     * @see {\@link NgForageConfig#DRIVER_SESSIONSTORAGE}
     * @return {?}
     */
    get driver() {
        if (typeof this[$defaultConfig].driver === 'string') {
            return this[$defaultConfig].driver;
        }
        return this[$defaultConfig].driver.slice();
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set driver(v) {
        this[$defaultConfig].driver = v;
    }
    /**
     * The name of the database. May appear during storage limit prompts. Useful to use the name of your app here.
     * In localStorage, this is used as a key prefix for all keys stored in localStorage.
     * \@default ngForage
     * @return {?}
     */
    get name() {
        return this[$defaultConfig].name;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set name(v) {
        this[$defaultConfig].name = v;
    }
    /**
     * The size of the database in bytes. Used only in WebSQL for now.
     * \@default 4980736
     * @return {?}
     */
    get size() {
        return this[$defaultConfig].size;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set size(v) {
        this[$defaultConfig].size = v;
    }
    /**
     * The name of the datastore.
     * In IndexedDB this is the dataStore,
     * in WebSQL this is the name of the key/value table in the database.
     * Must be alphanumeric, with underscores.
     * Any non-alphanumeric characters will be converted to underscores.
     * \@default ng_forage
     * @return {?}
     */
    get storeName() {
        return this[$defaultConfig].storeName;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set storeName(v) {
        this[$defaultConfig].storeName = v;
    }
    /**
     * The version of your database. May be used for upgrades in the future; currently unused.
     * \@default 1.0
     * @return {?}
     */
    get version() {
        return this[$defaultConfig].version;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set version(v) {
        this[$defaultConfig].version = v;
    }
    /**
     * Bulk-set configuration options
     * @param {?} opts The configuration
     * @return {?}
     */
    configure(opts) {
        opts = opts || {};
        if ('driver' in opts && opts.driver.slice) {
            opts.driver = opts.driver.slice();
        }
        Object.assign(this[$defaultConfig], opts);
        return this;
    }
    /**
     * Define a driver
     *
     * You’ll want to make sure you accept a callback argument and that you pass the same arguments to callbacks as the
     * default drivers do. You’ll also want to resolve or reject promises.
     * Check any of the {\@link https://github.com/mozilla/localForage/tree/master/src/drivers default drivers}
     * for an idea of how to implement your own, custom driver.
     * @param {?} spec Driver spec
     * @return {?}
     */
    defineDriver(spec) {
        return localForage.defineDriver(spec);
    }
    /**
     * \@internal
     * @return {?}
     */
    toJSON() {
        return this.config;
    }
    /**
     * @return {?}
     */
    toString() {
        return JSON.stringify(this.toJSON());
    }
}
/**
 * The IndexedDB driver
 */
NgForageConfig.DRIVER_INDEXEDDB = localForage.INDEXEDDB;
/**
 * The localStorage driver
 */
NgForageConfig.DRIVER_LOCALSTORAGE = localForage.LOCALSTORAGE;
/**
 * The sessionStorage driver
 */
NgForageConfig.DRIVER_SESSIONSTORAGE = _driver;
/**
 * The WebSQL driver
 */
NgForageConfig.DRIVER_WEBSQL = localForage.WEBSQL;
NgForageConfig.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] },
];
/** @nocollapse */
NgForageConfig.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DEFAULT_CONFIG,] },] },
];
/** @nocollapse */ NgForageConfig.ngInjectableDef = defineInjectable({ factory: function NgForageConfig_Factory() { return new NgForageConfig(inject(DEFAULT_CONFIG, 8)); }, token: NgForageConfig, providedIn: "root" });
Object.defineProperty(NgForageConfig.prototype, Symbol.toStringTag, { value: 'NgForageConfig' });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@internal
 */
const stores = {};
/**
 * \@internal
 * @param {?=} driver
 * @return {?}
 */
function getDriverString(driver) {
    if (!driver) {
        return '';
    }
    else if (typeof driver === 'string') {
        return driver;
    }
    else {
        return driver.slice().sort().join(',');
    }
}
/**
 * \@internal
 * @param {?} cfg
 * @return {?}
 */
function getHash(cfg) {
    return [
        getDriverString(cfg.driver),
        cfg.name,
        cfg.size,
        cfg.storeName,
        cfg.version,
        cfg.description,
        cfg.cacheTime
    ].join('|');
}
/**
 * \@internal
 */
const conf$ = Symbol('Config');
/**
 * Creates localForage instances
 */
class InstanceFactory {
    /**
     * \@internal
     * @param {?} conf
     */
    constructor(conf) {
        this[conf$] = conf;
    }
    /**
     * @param {?} cfg
     * @return {?}
     */
    getInstance(cfg) {
        cfg = Object.assign({}, this[conf$].config, cfg || {});
        const /** @type {?} */ hash = getHash(cfg);
        if (!stores[hash]) {
            stores[hash] = localForage.createInstance(cfg);
        }
        return stores[hash];
    }
}
InstanceFactory.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] },
];
/** @nocollapse */
InstanceFactory.ctorParameters = () => [
    { type: NgForageConfig, },
];
/** @nocollapse */ InstanceFactory.ngInjectableDef = defineInjectable({ factory: function InstanceFactory_Factory() { return new InstanceFactory(inject(NgForageConfig)); }, token: InstanceFactory, providedIn: "root" });
Object.defineProperty(InstanceFactory.prototype, Symbol.toStringTag, { value: 'InstanceFactory' });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@internal
 */
const store$ = Symbol('Store');
/**
 * Abstract service-level configuration layer for NgForage
 * @abstract
 */
class BaseConfigurableImpl {
    /**
     * \@internal
     * @param {?} config
     * @param {?} instanceFactory
     */
    constructor(config, instanceFactory) {
        /**
         * \@internal
         */
        this.config = {};
        /**
         * \@internal
         */
        this.storeNeedsRecalc = true;
        this.baseConfig = config;
        this.fact = instanceFactory;
    }
    /**
     * A description of the database, essentially for developer usage.
     * \@default ""
     * @return {?}
     */
    get description() {
        return 'description' in this.config ? this.config.description : this.baseConfig.description;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set description(v) {
        this.config.description = v;
        this.storeNeedsRecalc = true;
    }
    /**
     * The preferred driver(s) to use.
     * @see {\@link NgForageConfig#DRIVER_INDEXEDDB}
     * @see {\@link NgForageConfig#DRIVER_WEBSQL}
     * @see {\@link NgForageConfig#DRIVER_LOCALSTORAGE}
     * @see {\@link NgForageConfig#DRIVER_SESSIONSTORAGE}
     * \@default IndexedDB, WebSQL and localStorage
     * @return {?}
     */
    get driver() {
        return 'driver' in this.config ? this.config.driver : this.baseConfig.driver;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set driver(v) {
        this.config.driver = v;
        this.storeNeedsRecalc = true;
    }
    /**
     * The name of the database. May appear during storage limit prompts. Useful to use the name of your app here.
     * In localStorage, this is used as a key prefix for all keys stored in localStorage.
     * \@default ngForage
     * @return {?}
     */
    get name() {
        return 'name' in this.config ? this.config.name : this.baseConfig.name;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set name(v) {
        this.config.name = v;
        this.storeNeedsRecalc = true;
    }
    /**
     * The size of the database in bytes. Used only in WebSQL for now.
     * \@default 4980736
     * @return {?}
     */
    get size() {
        return 'size' in this.config ? this.config.size : this.baseConfig.size;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set size(v) {
        this.config.size = v;
        this.storeNeedsRecalc = true;
    }
    /**
     * The name of the datastore.
     * In IndexedDB this is the dataStore,
     * in WebSQL this is the name of the key/value table in the database.
     * Must be alphanumeric, with underscores.
     * Any non-alphanumeric characters will be converted to underscores.
     * \@default ng_forage
     * @return {?}
     */
    get storeName() {
        return 'storeName' in this.config ? this.config.storeName : this.baseConfig.storeName;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set storeName(v) {
        this.config.storeName = v;
        this.storeNeedsRecalc = true;
    }
    /**
     * The version of your database. May be used for upgrades in the future; currently unused.
     * \@default 1.0
     * @return {?}
     */
    get version() {
        return 'version' in this.config ? this.config.version : this.baseConfig.version;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set version(v) {
        this.config.version = v;
        this.storeNeedsRecalc = true;
    }
    /**
     * \@internal
     * @return {?}
     */
    get finalConfig() {
        return Object.assign({}, this.baseConfig.config, this.config);
    }
    /**
     * \@internal
     * @return {?}
     */
    get store() {
        if (this.storeNeedsRecalc || !this[store$]) {
            this[store$] = this.fact.getInstance(this.finalConfig);
            this.storeNeedsRecalc = false;
        }
        return this[store$];
    }
    /**
     * Bulk-set configuration options
     * @param {?} opts The configuration
     * @return {?}
     */
    configure(opts) {
        opts = opts || {};
        if ('driver' in opts && opts.driver.slice) {
            opts.driver = opts.driver.slice();
        }
        Object.assign(this.config, opts);
        this.storeNeedsRecalc = true;
        return this;
    }
    /**
     * \@internal
     * @return {?}
     */
    toJSON() {
        return {
            description: this.description,
            driver: this.driver,
            name: this.name,
            size: this.size,
            storeName: this.storeName,
            version: this.version
        };
    }
    /**
     * @return {?}
     */
    toString() {
        return JSON.stringify(this.toJSON());
    }
}
/** @nocollapse */
BaseConfigurableImpl.ctorParameters = () => [
    { type: NgForageConfig, decorators: [{ type: Inject, args: [NgForageConfig,] },] },
    { type: InstanceFactory, decorators: [{ type: Inject, args: [InstanceFactory,] },] },
];
Object.defineProperty(BaseConfigurableImpl.prototype, Symbol.toStringTag, { value: 'BaseConfigurable' });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Cache instance
 */
class NgForage extends BaseConfigurableImpl {
    /**
     * Returns the name of the driver being used, or null if none can be used.
     * @return {?}
     */
    get activeDriver() {
        return this.store.driver();
    }
    /**
     * Removes every key from the database, returning it to a blank slate.
     *
     * clear() will remove <b>every item in the offline store</b>. Use this method with caution.
     * @return {?}
     */
    clear() {
        return this.store.clear();
    }
    /**
     * Make a clone of the instance
     * @param {?=} config Optional configuration
     * @return {?}
     */
    clone(config) {
        const /** @type {?} */ inst = new NgForage(this.baseConfig, this.fact);
        inst.configure(Object.assign(this.finalConfig, config || {}));
        return inst;
    }
    /**
     * Gets an item from the storage library.
     * If the key does not exist, getItem() will return null.
     * @template T
     * @param {?} key Data key
     * @return {?}
     */
    getItem(key) {
        return this.store.getItem(key);
    }
    /**
     * Iterate over all value/key pairs in datastore.
     * <i>iteratee</i> is called once for each pair, with the following arguments:
     * <ol>
     *   <li>Value</li>
     *   <li>Key</li>
     *   <li>iterationNumber - one-based number</li>
     * </ol>
     * iterate() supports early exit by returning non undefined value inside iteratorCallback callback.
     * @template T, U
     * @param {?} iteratee
     * @return {?}
     */
    iterate(iteratee) {
        return this.store.iterate(iteratee);
    }
    /**
     * Get the name of a key based on its ID.
     * @param {?} index
     * @return {?}
     */
    key(index) {
        return this.store.key(index);
    }
    /**
     * Get the list of all keys in the datastore.
     * @return {?}
     */
    keys() {
        return this.store.keys();
    }
    /**
     * Gets the number of keys in the offline store (i.e. its “length”).
     * @return {?}
     */
    length() {
        return this.store.length();
    }
    /**
     * Even though localForage queues up all of its data API method calls,
     * ready() provides a way to determine whether the asynchronous driver initialization process has finished.
     * That’s useful in cases like when we want to know which driver localForage has settled down using.
     * @return {?}
     */
    ready() {
        return this.store.ready();
    }
    /**
     * Removes the value of a key from the offline store.
     * @param {?} key Data key
     * @return {?}
     */
    removeItem(key) {
        return this.store.removeItem(key);
    }
    /**
     * Saves data to an offline store. You can store the following types of JavaScript objects:
     * <ul>
     *  <li>Array</li>
     *  <li>ArrayBuffer</li>
     *  <li>Blob</li>
     *  <li>Float32Array</li>
     *  <li>Float64Array</li>
     *  <li>Int8Array</li>
     *  <li>Int16Array</li>
     *  <li>Int32Array</li>
     *  <li>Number</li>
     *  <li>Object</li>
     *  <li>Uint8Array</li>
     *  <li>Uint8ClampedArray</li>
     *  <li>Uint16Array</li>
     *  <li>Uint32Array</li>
     *  <li>String</li>
     * </ul>
     * @template T
     * @param {?} key Data key
     * @param {?} data Data
     * @return {?}
     */
    setItem(key, data) {
        return this.store.setItem(key, data);
    }
    /**
     * Check whether the given driver is supported/registered.
     * @param {?} driver Driver name
     * @return {?}
     */
    supports(driver) {
        return this.store.supports(driver);
    }
}
NgForage.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] },
];
/** @nocollapse */ NgForage.ngInjectableDef = defineInjectable({ factory: function NgForage_Factory() { return new NgForage(inject(NgForageConfig), inject(InstanceFactory)); }, token: NgForage, providedIn: "root" });
Object.defineProperty(NgForage.prototype, Symbol.toStringTag, { value: 'NgForage' });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@internal
 * @template T
 */
class CachedItemImpl {
    /**
     * @param {?} data
     * @param {?} expiryTime
     */
    constructor(data, expiryTime) {
        this.data = data;
        this.expires = new Date(typeof expiryTime === 'number' ? expiryTime : 0);
    }
    /**
     * @return {?}
     */
    get expired() {
        return this.expiresIn === 0;
    }
    /**
     * @return {?}
     */
    get expiresIn() {
        return Math.max(0, this.expires.getTime() - Date.now());
    }
    /**
     * @return {?}
     */
    get hasData() {
        return this.data !== null;
    }
    /**
     * @return {?}
     */
    toJSON() {
        return {
            data: this.data,
            expired: this.expired,
            expires: this.expires,
            expiresIn: this.expiresIn,
            hasData: this.hasData
        };
    }
    /**
     * @return {?}
     */
    toString() {
        return JSON.stringify(this.toJSON());
    }
}
__decorate([
    LazyGetter(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], CachedItemImpl.prototype, "expired", null);
__decorate([
    LazyGetter(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [])
], CachedItemImpl.prototype, "expiresIn", null);
__decorate([
    LazyGetter(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [])
], CachedItemImpl.prototype, "hasData", null);
Object.defineProperty(CachedItemImpl.prototype, Symbol.toStringTag, { value: 'CachedItem' });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@internal
 * @param {?} mainKey
 * @return {?}
 */
function calculateCacheKeys(mainKey) {
    return {
        data: `${mainKey}_data`,
        expiry: `${mainKey}_expiry`
    };
}
/**
 * \@internal
 * @template T
 * @param {?} r
 * @return {?}
 */
function toCachedItem(r) {
    return new CachedItemImpl(r[0], r[1]);
}
/**
 * \@internal
 * @template T
 * @param {?} r
 * @return {?}
 */
function head(r) {
    return r[0];
}
/**
 * \@internal
 * @return {?}
 */
function toVoid() {
}
/**
 * An extension of {\@link NgForage} which adds expiration support
 */
class NgForageCache extends NgForage {
    /**
     * Cache time in milliseconds
     * \@default 300000
     * @return {?}
     */
    get cacheTime() {
        return 'cacheTime' in this.config ? this.config.cacheTime : this.baseConfig.cacheTime;
    }
    /**
     * @param {?} t
     * @return {?}
     */
    set cacheTime(t) {
        this.config.cacheTime = t;
        this.storeNeedsRecalc = true;
    }
    /**
     * @inheritDoc
     * @param {?=} config
     * @return {?}
     */
    clone(config) {
        const /** @type {?} */ inst = new NgForageCache(this.baseConfig, this.fact);
        inst.configure(Object.assign(this.finalConfig, config || {}));
        return inst;
    }
    /**
     * Retrieve data
     * @template T
     * @param {?} key Data key
     * @return {?}
     */
    getCached(key) {
        const /** @type {?} */ keys = calculateCacheKeys(key);
        const /** @type {?} */ dataPromise = this.getItem(keys.data);
        const /** @type {?} */ expiryPromise = this.getItem(keys.expiry);
        return Promise.all([dataPromise, expiryPromise]).then(toCachedItem);
    }
    /**
     * Remove data
     * @param {?} key Data key
     * @return {?}
     */
    removeCached(key) {
        const /** @type {?} */ keys = calculateCacheKeys(key);
        const /** @type {?} */ dataPromise = this.removeItem(keys.data);
        const /** @type {?} */ expiryPromise = this.removeItem(keys.expiry);
        return Promise.all([dataPromise, expiryPromise]).then(toVoid);
    }
    /**
     * Set data
     * @template T
     * @param {?} key Data key
     * @param {?} data Data to set
     * @param {?=} cacheTime
     * @return {?}
     */
    setCached(key, data, cacheTime) {
        const /** @type {?} */ keys = calculateCacheKeys(key);
        const /** @type {?} */ expiry = typeof cacheTime === 'number' ? cacheTime : this.cacheTime;
        const /** @type {?} */ dataPromise = this.setItem(keys.data, data);
        const /** @type {?} */ expiryPromise = this.setItem(keys.expiry, Date.now() + expiry);
        return Promise.all([dataPromise, expiryPromise]).then(head);
    }
    /**
     * \@internal
     * @return {?}
     */
    toJSON() {
        const /** @type {?} */ ass = { cacheTime: this.cacheTime };
        return Object.assign(super.toJSON(), ass);
    }
}
NgForageCache.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] },
];
/** @nocollapse */ NgForageCache.ngInjectableDef = defineInjectable({ factory: function NgForageCache_Factory() { return new NgForageCache(inject(NgForageConfig), inject(InstanceFactory)); }, token: NgForageCache, providedIn: "root" });
Object.defineProperty(NgForageCache.prototype, Symbol.toStringTag, { value: 'NgForageCache' });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@internal
 */
class NgForageCacheDedicated extends NgForageCache {
    /**
     * @param {?=} config
     * @return {?}
     */
    clone(config) {
        const /** @type {?} */ inst = new NgForageCacheDedicated(this.baseConfig, this.fact);
        inst.configure(Object.assign(this.finalConfig, config || {}));
        return inst;
    }
}
Object.defineProperty(NgForageCacheDedicated.prototype, Symbol.toStringTag, { value: 'NgForageCache (dedicated)' });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@internal
 */
class NgForageDedicated extends NgForage {
    /**
     * @param {?=} config
     * @return {?}
     */
    clone(config) {
        const /** @type {?} */ inst = new NgForageDedicated(this.baseConfig, this.fact);
        inst.configure(Object.assign(this.finalConfig, config || {}));
        return inst;
    }
}
Object.defineProperty(NgForageDedicated.prototype, Symbol.toStringTag, { value: 'NgForage (dedicated)' });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@internal
 */
const conf$$1 = Symbol('NgForageConfig');
/**
 * \@internal
 */
const if$ = Symbol('InstanceFactory');
class DedicatedInstanceFactory {
    /**
     * @param {?} conf
     * @param {?} instFact
     */
    constructor(conf, instFact) {
        this[conf$$1] = conf;
        this[if$] = instFact;
    }
    /**
     * @param {?=} config
     * @return {?}
     */
    createCache(config) {
        const /** @type {?} */ inst = new NgForageCacheDedicated(/** @type {?} */ (this[conf$$1]), /** @type {?} */ (this[if$]));
        if (config) {
            inst.configure(config);
        }
        return inst;
    }
    /**
     * @param {?=} config
     * @return {?}
     */
    createNgForage(config) {
        const /** @type {?} */ inst = new NgForageDedicated(/** @type {?} */ (this[conf$$1]), /** @type {?} */ (this[if$]));
        if (config) {
            inst.configure(config);
        }
        return inst;
    }
}
DedicatedInstanceFactory.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] },
];
/** @nocollapse */
DedicatedInstanceFactory.ctorParameters = () => [
    { type: NgForageConfig, },
    { type: InstanceFactory, },
];
/** @nocollapse */ DedicatedInstanceFactory.ngInjectableDef = defineInjectable({ factory: function DedicatedInstanceFactory_Factory() { return new DedicatedInstanceFactory(inject(NgForageConfig), inject(InstanceFactory)); }, token: DedicatedInstanceFactory, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

export { NgForageModule, NgForage, NgForageCache, NgForageConfig, InstanceFactory, DedicatedInstanceFactory, DEFAULT_CONFIG as ɵa, BaseConfigurableImpl as ɵb };
//# sourceMappingURL=ngforage.js.map
